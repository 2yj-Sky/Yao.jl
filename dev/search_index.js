var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"CurrentModule = Yao","category":"page"},{"location":"#Yao-1","page":"Home","title":"Yao","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A General Purpose Quantum Computation Simulation Framework","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Welcome to Yao, a Flexible, Extensible, Efficient Framework for Quantum Algorithm Design. Yao (幺) is the Chinese character for normalized but not orthogonal.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We aim to provide a powerful tool for researchers, students to study and explore quantum computing in near term future, before quantum computer being used in large-scale.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Yao is a Julia language package, to install Yao, you need to install Julia first.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After you have Julia installed, simply open Julia's interactive session and type ] and then type the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add Yao","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you have problem with installation, please file us an issue!","category":"page"},{"location":"#Getting-Started-1","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"examples/GHZ.md\",\n    \"examples/QFT.md\",\n    \"examples/Grover.md\",\n    \"examples/QCBM.md\",\n]\nDepth = 1","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"man/array_registers.md\",\n    \"man/blocks.md\",\n    \"man/base.md\",\n    \"man/registers.md\",\n    \"man/extending_blocks.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/GHZ/#example-ghz-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"First, you have to use this package in Julia.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"using Yao","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Now, we just define the circuit according to the circuit image below:","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(Image: ghz)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"circuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\nchain\n├─ put on (1)\n│  └─ X gate\n├─ repeat on (2, 3, 4)\n│  └─ H gate\n├─ control(2)\n│  └─ (1,) X gate\n├─ control(4)\n│  └─ (3,) X gate\n├─ control(3)\n│  └─ (1,) X gate\n├─ control(4)\n│  └─ (3,) X gate\n└─ repeat on (1, 2, 3, 4)\n   └─ H gate","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Let me explain what happens here.","category":"page"},{"location":"examples/GHZ/#Put-single-qubit-gate-X-to-location-1-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Put single qubit gate X to location 1","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"we have an X gate applied to the first qubit.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"We need to tell Yao to put this gate on the first qubit by","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(4, 1=>X)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\nput on (1)\n└─ X gate","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"We use Julia's Pair to denote the gate and its location in the circuit, for two-qubit gate, you could also use a tuple of locations:","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(4, (1, 2)=>swap(2, 1, 2))","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\nput on (1, 2)\n└─ swap(1, 2)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"But, wait, why there's no 4 in the definition above? This is because all the functions in Yao that requires to input the number of qubits as its first arguement could be lazy (curried), and let other constructors to infer the total number of qubits later, e.g","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(1=>X)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(n -> put(n, 1 => X gate))","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"which will return a lambda that ask for a single arguement n.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(1=>X)(4)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\nput on (1)\n└─ X gate","category":"page"},{"location":"examples/GHZ/#Apply-the-same-gate-on-different-locations-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Apply the same gate on different locations","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"next we should put Hadmard gates on all locations except the 1st qubits.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"We provide repeat to apply the same block repeatly, repeat can take an iterator of desired locations, and like put, we can also leave the total number of qubits there.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"repeat(H, 2:4)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(n -> repeat(n, H gate, 2, 3, 4))","category":"page"},{"location":"examples/GHZ/#Define-control-gates-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Define control gates","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"In Yao, we could define controlled gates by feeding a gate to control","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"control(4, 2, 1=>X)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\ncontrol(2)\n└─ (1,) X gate","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Like many others, you could leave the number of total qubits there, and infer it later.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"control(2, 1=>X)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(n -> control(n, 2, 1 => X gate))","category":"page"},{"location":"examples/GHZ/#Composite-each-part-together-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Composite each part together","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"This will create a ControlBlock, the concept of block in Yao basically just means quantum operators, since the quantum circuit itself is a quantum operator, we could create a quantum circuit by composite each part of.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Here, we use chain to chain each part together, a chain of quantum operators means to apply each operators one by one in the chain. This will create a ChainBlock.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"circuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"nqubits: 4, datatype: Complex{Float64}\nchain\n├─ put on (1)\n│  └─ X gate\n├─ repeat on (2, 3, 4)\n│  └─ H gate\n├─ control(2)\n│  └─ (1,) X gate\n├─ control(4)\n│  └─ (3,) X gate\n├─ control(3)\n│  └─ (1,) X gate\n├─ control(4)\n│  └─ (3,) X gate\n└─ repeat on (1, 2, 3, 4)\n   └─ H gate","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"You can check the type of it with typeof","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"typeof(circuit)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ChainBlock{4,Complex{Float64}}","category":"page"},{"location":"examples/GHZ/#Construct-GHZ-state-from-00...00-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Construct GHZ state from 00...00","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"For simulation, we provide a builtin register type called ArrayReg, we will use the simulated register in this example.","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"First, let's create 0000, you can create it with zero_state","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"zero_state(4)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 4/4","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Or we also provide bit string literals to create arbitrary eigen state","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ArrayReg(bit\"0000\")","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 4/4","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"They will both create a register with Julia's builtin Array as storage.","category":"page"},{"location":"examples/GHZ/#Feed-Registers-to-Circuits-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Feed Registers to Circuits","text":"","category":"section"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Circuits can be applied to registers with apply!","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"apply!(zero_state(4), circuit)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 4/4","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"or you can use pipe operator |>, when you want to chain several operations together, here we measure the state right after the circuit for 1000 times","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"results = zero_state(4) |> circuit |> r->measure(r, nshots=1000)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"1000-element Array{Int64,1}:\n 15\n  0\n  0\n  0\n 15\n 15\n  0\n 15\n 15\n 15\n  ⋮\n  0\n  0\n  0\n 15\n 15\n 15\n  0\n 15\n  0","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(Image: GHZ)","category":"page"},{"location":"examples/GHZ/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"GHZ state will collapse to 0000 or 1111.","category":"page"},{"location":"examples/QFT/#Quantum-Fourier-Transformation-and-Phase-Estimation-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"","category":"section"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Let's use Yao first","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using Yao","category":"page"},{"location":"examples/QFT/#Quantum-Fourier-Transformation-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation","text":"","category":"section"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The Quantum Fourier Transformation (QFT) circuit is to repeat two kinds of blocks repeatly:","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: ghz)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The basic building block control phase shift gate is defined as","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R(k)=beginbmatrix\n1  0\n0  expleft(frac2pi i2^kright)\nendbmatrix","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Let's define block A and block B, block A is actually a control block.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"A(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"A (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Once you construct the blockl you can inspect its matrix using mat function. Let's construct the circuit in dash box A, and see the matrix of R_4 gate.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R4 = A(1, 4)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(n -> control(n, 1, 4 => shift(Inf)))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"If you have read about preparing GHZ state, you probably know that in Yao, we could just leave the number of qubits, and it will be evaluated when possible.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R4(5)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"nqubits: 5, datatype: Complex{Float64}\ncontrol(1)\n└─ (4,) shift(Inf)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"its matrix will be","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"mat(R4(5))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"32×32 LinearAlgebra.Diagonal{Complex{Float64},Array{Complex{Float64},1}}:\n 1.0+0.0im      ⋅          ⋅      …      ⋅           ⋅          ⋅     \n     ⋅      1.0+0.0im      ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅      1.0+0.0im         ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅      …      ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n    ⋮                             ⋱                 ⋮                 \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅      …      ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅          ⋅     \n     ⋅          ⋅          ⋅         NaN+NaN*im      ⋅          ⋅     \n     ⋅          ⋅          ⋅      …      ⋅       1.0+0.0im      ⋅     \n     ⋅          ⋅          ⋅             ⋅           ⋅      NaN+NaN*im","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Then we repeat this control block over and over on different qubits, and put a Hadamard gate to ith qubit to construct i-th B block.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"B(n, i) = chain(n, i==j ? put(i=>H) : A(j, i) for j in i:n)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"B (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"We need to input the total number of qubits n here because we have to iterate through from i-th location to the last.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now, let's construct the circuit by chaining all the B blocks together","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"qft(n) = chain(B(n, i) for i in 1:n)\n\nqft(4)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"nqubits: 4, datatype: Complex{Float64}\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ H gate\n│  ├─ control(2)\n│  │  └─ (1,) shift(1.5707963267948966)\n│  ├─ control(3)\n│  │  └─ (1,) shift(0.7853981633974483)\n│  └─ control(4)\n│     └─ (1,) shift(0.39269908169872414)\n├─ chain\n│  ├─ put on (2)\n│  │  └─ H gate\n│  ├─ control(3)\n│  │  └─ (2,) shift(1.5707963267948966)\n│  └─ control(4)\n│     └─ (2,) shift(0.7853981633974483)\n├─ chain\n│  ├─ put on (3)\n│  │  └─ H gate\n│  └─ control(4)\n│     └─ (3,) shift(1.5707963267948966)\n└─ chain\n   └─ put on (4)\n      └─ H gate","category":"page"},{"location":"examples/QFT/#Wrap-QFT-to-an-external-block-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Wrap QFT to an external block","text":"","category":"section"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In most cases, functions are enough to wrap quantum circuits, like A and B we defined above, but sometimes, we need to dispatch specialized methods on certain kinds of quantum circuit, or we want to define an external block to export, thus, it's useful to be able to wrap circuit to custom blocks.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First, we define a new type as subtype of PrimitiveBlock since we are not going to use the subblocks of QFT, if you need to use its subblocks, it'd be better to define it under CompositeBlock.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"struct QFT{N} <: PrimitiveBlock{N} end","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: invalid subtyping in definition of QFT","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT(n::Int) = QFT{n}()","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now, let's define its circuit","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"circuit(::QFT{N}) where N = qft(N)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"And forward mat to its circuit's matrix","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"YaoBlocks.mat(::Type{T}, x::QFT) where T = mat(T, circuit(x))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: ArgumentError: invalid type for argument x in method definition for \nmat at none:1","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"You may notice, it is a little ugly to print QFT at the moment, this is because we print the type summary by default, you can define your own printing by overloading print_block","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"YaoBlocks.print_block(io::IO, x::QFT{N}) where N = print(io, \"QFT($N)\")","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since it is possible to use FFT to simulate the results of QFT (like cheating), we could define our custom apply! method:","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using FFTW, LinearAlgebra\n\nfunction YaoBlocks.apply!(r::ArrayReg, x::QFT)\n    α = sqrt(length(statevec(r)))\n    invorder!(r)\n    lmul!(α, ifft!(statevec(r)))\n    return r\nend","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: ArgumentError: invalid type for argument x in method definition for \napply! at none:3","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now let's check if our apply! method is correct:","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = rand_state(5)\nr1 = r |> copy |> QFT(5)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r2 = r |> copy |> circuit(QFT(5))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r1 ≈ r2","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: UndefVarError: r1 not defined","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"We can get iQFT (inverse QFT) directly by calling adjoint","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT(5)'","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT and iQFT are different from FFT and IFFT in three ways,","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"they are different by a factor of sqrt2^n with n the number of qubits.\nthe bit numbering will exchange after applying QFT or iQFT.\ndue to the convention, QFT is more related to IFFT rather than FFT.","category":"page"},{"location":"examples/QFT/#Phase-Estimation-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Phase Estimation","text":"","category":"section"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since we have QFT and iQFT blocks we can then use them to realize phase estimation circuit, what we want to realize is the following circuit:","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: phase estimation)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using Yao","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First we call Hadamard gates repeatly on first n qubits.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Hadamards(n) = repeat(H, 1:n)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Hadamards (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Then in dashed box B, we have controlled unitaries:","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ControlU(n, m, U) = chain(n+m, control(k, n+1:n+m=>matblock(U^(2^(k-1)))) for k in 1:n)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ControlU (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"each of them is a U of power 2^(k-1).","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since we will only apply the qft and Hadamard on first n qubits, we could use Concentrator, which creates a context of a sub-scope of the qubits.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"PE(n, m, U) =\n    chain(n+m, # total number of the qubits\n        concentrate(Hadamards(n), 1:n), # apply H in local scope\n        ControlU(n, m, U),\n        concentrate(QFT(n)', 1:n))","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"PE (generic function with 1 method)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"we use the first n qubits as the output space to store phase ϕ, and the other m qubits as the input state which corresponds to an eigenvector of oracle matrix U.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The concentrator here uses focus! and relax! to manage a local scope of quantum circuit, and only active the first n qubits while applying the block inside the concentrator context, and the scope will be relax!ed back, after the context. This is equivalent to manually focus! then relax!","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"fullly activated","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = rand_state(5)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 5/5","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"first 3 qubits activated","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"focus!(r, 1:3)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 3/5","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"relax back to the original","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"relax!(r, 1:3)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 5/5","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In this way, we will be able to apply small operator directly on the subset of the qubits.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Details about the algorithm can be found here: Quantum Phase Estimation Algorithm","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now let's check the results of our phase estimation.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First we need to set up a unitary with known phase, we set the phase to be 0.75, which is 0.75 * 2^3 == 6 == 0b110 .","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using LinearAlgebra\n\nN, M = 3, 5\nP = eigen(rand_unitary(1<<M)).vectors\nθ = Int(0b110) / 1<<N\nphases = rand(1<<M)\nphases[bit\"010\"] = θ\nU = P * Diagonal(exp.(2π * im * phases)) * P'","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"32×32 Array{Complex{Float64},2}:\n   0.0322996+0.116447im      0.268227-0.0139611im  …    0.0697985+0.0928288\nim\n   0.0676947-0.0160998im    -0.150349+0.154822im         0.172247+0.0149547\nim\n   0.0948438-0.139358im    -0.0731316-0.0597185im       -0.173621-0.162442i\nm \n   -0.132349-0.0931924im    -0.123077-0.158073im       -0.0419451+0.214237i\nm \n    0.161144-0.0358338im   -0.0872153-0.0584477im       0.0627779+0.0964814\nim\n   0.0378395+0.0708035im     0.131945-0.0600205im  …    0.0184074-0.0985794\nim\n  -0.0691375+0.0694063im   -0.0234908-0.0938884im       -0.106847-0.123579i\nm \n    0.198446+0.165598im      0.259368+0.0304677im       -0.227246+0.133751i\nm \n  -0.0875145-0.084737im     0.0710333+0.0425882im        0.206331+0.064761i\nm \n    -0.12792+0.139975im     -0.139616-0.0423442im        0.111821+0.0744895\nim\n            ⋮                                      ⋱                       \n  \n  -0.0409844-0.0448699im    0.0490512+0.129604im        -0.370215+0.11562im\n  \n   -0.282629+0.00299807im  -0.0298105+0.0456496im        0.126355-0.170207i\nm \n    0.115137-0.0974906im    0.0708612+0.0681874im  …  -0.00562827-0.139167i\nm \n   -0.116589-0.094355im     -0.032366-0.12472im          0.012487-0.0239367\nim\n    0.251512+0.0754319im     0.178269-0.0230921im       0.0859338+0.0772281\nim\n    0.239801+0.176476im     0.0304284-0.143im           -0.127369+0.0902052\nim\n 0.000986835+0.00359916im    0.195426-0.20112im         0.0248881-0.104742i\nm \n   0.0399215-0.179808im      -0.15634+0.138115im   …    -0.149674-0.0892364\nim\n   0.0842137-0.0202052im   -0.0438315-0.247437im        0.0562255+0.114902i\nm","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"and then generate the state ψ","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"psi = P[:, 3]","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"32-element Array{Complex{Float64},1}:\n -0.054054456006083426 - 0.3016799374554241im  \n   -0.0053918179663731 + 0.018363897233838352im\n  -0.04219218001048543 - 0.34686484271936324im \n   0.13088589196402628 - 0.24943549393522724im \n   -0.1089162564856683 - 0.09738629662863243im \n -0.037579386418121176 - 0.12692027946245463im \n  -0.05790692158257322 + 0.09290264057663451im \n  -0.05269284159695046 + 0.07065863293242997im \n   0.03791056958434424 - 0.11971733338571741im \n -0.033523678848360446 - 0.044405065157818245im\n                       ⋮                       \n   0.06694233036410482 - 0.11464315133422369im \n    -0.084554207592195 - 0.016246407261182316im\n   0.18160878485638843 - 0.09403687817590345im \n  -0.13876631148323293 + 0.22564023037919048im \n   0.35160626378502113 + 0.0im                 \n -0.027675152004786315 - 0.11739762727294555im \n   0.11212436765184344 + 0.0772728352937729im  \n   0.09119563569106434 - 0.17240472506598653im \n   0.03746624497361033 + 0.029767119775263976im","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In the phase estimation process, we will feed the state to circuit and measure the first n qubits processed by iQFT.","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = join(ArrayReg(psi), zero_state(N))\nr |> PE(N, M, U)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Error: TypeError: in Type{...} expression, expected UnionAll, got typeof(Ma\nin.WeaveSandBox1.QFT)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since our phase can be represented by 3 qubits precisely, we only need to measure once","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"results = measure(r, 1:N; nshots=1)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"1-element Array{Int64,1}:\n 0","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Recall that our QFT's bit numbering is reversed, let's reverse it back","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using BitBasis\nestimated_phase = bfloat(results[]; nbits=N)","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"0.0","category":"page"},{"location":"examples/QFT/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"the phase is exactly 0.75!","category":"page"},{"location":"examples/QCBM/#qcbm-1","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Yao is designed with variational quantum circuits in mind, and this tutorial will introduce how to use Yao for this kind of task by implementing a quantum circuit born machine described in Jin-Guo Liu, Lei Wang (2018)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"let's use the package first","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"using Yao, LinearAlgebra","category":"page"},{"location":"examples/QCBM/#Training-Target-1","page":"Quantum Circuit Born Machine","title":"Training Target","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In this tutorial, we will ask the variational circuit to learn the most basic distribution: a guassian distribution. It is defined as follows:","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"f(x left mu sigma^2right) = frac1sqrt2pisigma^2 e^-frac(x-mu)^22sigma^2","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We implement it as gaussian_pdf:","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function gaussian_pdf(x, μ::Real, σ::Real)\n    pl = @. 1 / sqrt(2pi * σ^2) * exp(-(x - μ)^2 / (2 * σ^2))\n    pl / sum(pl)\nend\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can plot the distribution, it looks like","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: Gaussian Distribution)","category":"page"},{"location":"examples/QCBM/#Create-the-Circuit-1","page":"Quantum Circuit Born Machine","title":"Create the Circuit","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"A quantum circuit born machine looks like the following:","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: differentiable ciruit)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"It is composited by two different layers: rotation layer and entangler layer.","category":"page"},{"location":"examples/QCBM/#Rotation-Layer-1","page":"Quantum Circuit Born Machine","title":"Rotation Layer","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Arbitrary rotation is built with Rotation Gate on Z, X, Z axis with parameters.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Rz(theta) cdot Rx(theta) cdot Rz(theta)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Since our input will be a 0dots 0rangle state. The first layer of arbitrary rotation can just use Rx(theta) cdot Rz(theta) and the last layer of arbitrary rotation could just use Rz(theta)cdot Rx(theta)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In 幺, every Hilbert operator is a block type, this ncludes all quantum gates and quantum oracles. In general, operators appears in a quantum circuit can be divided into Composite Blocks and Primitive Blocks.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We follow the low abstraction principle and thus each block represents a certain approach of calculation. The simplest Composite Block is a Chain Block, which chains other blocks (oracles) with the same number of qubits together. It is just a simple mathematical composition of operators with same size. e.g.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"textchain(X Y Z) iff X cdot Y cdot Z","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can construct an arbitrary rotation block by chain Rz, Rx, Rz together.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"chain(Rz(0.0), Rx(0.0), Rz(0.0))","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"nqubits: 1, datatype: Complex{Float64}\nchain\n├─ rot(Z gate, 0.0)\n├─ rot(X gate, 0.0)\n└─ rot(Z gate, 0.0)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Rx, Rz will construct new rotation gate, which are just shorthands for rot(X, 0.0), etc.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Then let's chain them up","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"layer(nbit::Int, x::Symbol) = layer(nbit, Val(x))\nlayer(nbit::Int, ::Val{:first}) = chain(nbit, put(i=>chain(Rx(0), Rz(0))) for i = 1:nbit);","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We do not need to feed the first n parameter into put here. All factory methods can be lazy evaluate the first arguements, which is the number of qubits. It will return a lambda function that requires a single interger input. The instance of desired block will only be constructed until all the information is filled. When you filled all the information in somewhere of the declaration, 幺 will be able to infer the others. We will now define the rest of rotation layers","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"layer(nbit::Int, ::Val{:last}) = chain(nbit, put(i=>chain(Rz(0), Rx(0))) for i = 1:nbit)\nlayer(nbit::Int, ::Val{:mid}) = chain(nbit, put(i=>chain(Rz(0), Rx(0), Rz(0))) for i = 1:nbit);","category":"page"},{"location":"examples/QCBM/#Entangler-1","page":"Quantum Circuit Born Machine","title":"Entangler","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Another component of quantum circuit born machine are several CNOT operators applied on different qubits.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"entangler(pairs) = chain(control(ctrl, target=>X) for (ctrl, target) in pairs);","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can then define such a born machine","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function build_circuit(n, nlayers, pairs)\n    circuit = chain(n)\n    push!(circuit, layer(n, :first))\n    for i in 2:nlayers\n        push!(circuit, cache(entangler(pairs)))\n        push!(circuit, layer(n, :mid))\n    end\n    push!(circuit, cache(entangler(pairs)))\n    push!(circuit, layer(n, :last))\n    return circuit\nend","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"build_circuit (generic function with 1 method)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We use the method cache here to tag the entangler block that it should be cached after its first run, because it is actually a constant oracle. Let's see what will be constructed","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"build_circuit(4, 1, [1=>2, 2=>3, 3=>4])","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"nqubits: 4, datatype: Complex{Float64}\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ chain\n│  │     ├─ rot(X gate, 0.0)\n│  │     └─ rot(Z gate, 0.0)\n│  ├─ put on (2)\n│  │  └─ chain\n│  │     ├─ rot(X gate, 0.0)\n│  │     └─ rot(Z gate, 0.0)\n│  ├─ put on (3)\n│  │  └─ chain\n│  │     ├─ rot(X gate, 0.0)\n│  │     └─ rot(Z gate, 0.0)\n│  └─ put on (4)\n│     └─ chain\n│        ├─ rot(X gate, 0.0)\n│        └─ rot(Z gate, 0.0)\n├─ [cached] chain\n│     ├─ control(1)\n│     │  └─ (2,) X gate\n│     ├─ control(2)\n│     │  └─ (3,) X gate\n│     └─ control(3)\n│        └─ (4,) X gate\n└─ chain\n   ├─ put on (1)\n   │  └─ chain\n   │     ├─ rot(Z gate, 0.0)\n   │     └─ rot(X gate, 0.0)\n   ├─ put on (2)\n   │  └─ chain\n   │     ├─ rot(Z gate, 0.0)\n   │     └─ rot(X gate, 0.0)\n   ├─ put on (3)\n   │  └─ chain\n   │     ├─ rot(Z gate, 0.0)\n   │     └─ rot(X gate, 0.0)\n   └─ put on (4)\n      └─ chain\n         ├─ rot(Z gate, 0.0)\n         └─ rot(X gate, 0.0)","category":"page"},{"location":"examples/QCBM/#MMD-Loss-and-Gradients-1","page":"Quantum Circuit Born Machine","title":"MMD Loss & Gradients","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"The MMD loss is describe below:","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"beginaligned\nmathcalL = left sum_x p theta(x) phi(x) - sum_x pi(x) phi(x) right^2\n            = langle K(x y) rangle_x sim p_theta ysim p_theta - 2 langle K(x y) rangle_xsim p_theta ysim pi + langle K(x y) rangle_xsimpi ysimpi\nendaligned","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We will use a squared exponential kernel here.","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"struct RBFKernel\n    σ::Float64\n    m::Matrix{Float64}\nend\n\nfunction RBFKernel(σ::Float64, space)\n    dx2 = (space .- space').^2\n    return RBFKernel(σ, exp.(-1/2σ * dx2))\nend\n\nkexpect(κ::RBFKernel, x, y) = x' * κ.m * y","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"kexpect (generic function with 1 method)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"There are two different way to define the loss:","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In simulation we can use the probability distribution of the state directly","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"get_prob(qcbm) = probs(zero_state(nqubits(qcbm)) |> qcbm)\n\nfunction loss(κ, c, target)\n    p = get_prob(c) - target\n    return kexpect(κ, p, p)\nend","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"loss (generic function with 1 method)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Or if you want to simulate the whole process with measurement (which is entirely physical), you should define the loss with measurement results, for convenience we directly use the simulated results as our loss","category":"page"},{"location":"examples/QCBM/#Gradients-1","page":"Quantum Circuit Born Machine","title":"Gradients","text":"","category":"section"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"the gradient of MMD loss is","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"beginaligned\nfracpartial mathcalLpartial theta^i_l = langle K(x y) rangle_xsim p_theta^+ ysim p_theta - langle K(x y) rangle_xsim p_theta^- ysim p_theta\n- langle K(x y) rangle _xsim p_theta^+ ysimpi + langle K(x y) rangle_xsim p_theta^- ysimpi\nendaligned","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"which can be implemented as","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function gradient(qcbm, κ, ptrain)\n    n = nqubits(qcbm)\n    prob = get_prob(qcbm)\n    grad = zeros(Float64, nparameters(qcbm))\n\n    count = 1\n    for k in 1:2:length(qcbm), each_line in qcbm[k], gate in content(each_line)\n        dispatch!(+, gate, π/2)\n        prob_pos = probs(zero_state(n) |> qcbm)\n\n        dispatch!(-, gate, π)\n        prob_neg = probs(zero_state(n) |> qcbm)\n\n        dispatch!(+, gate, π/2) # set back\n\n        grad_pos = kexpect(κ, prob, prob_pos) - kexpect(κ, prob, prob_neg)\n        grad_neg = kexpect(κ, ptrain, prob_pos) - kexpect(κ, ptrain, prob_neg)\n        grad[count] = grad_pos - grad_neg\n        count += 1\n    end\n    return grad\nend","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"gradient (generic function with 1 method)","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Now let's setup the training","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"using Flux.Optimise\nqcbm = build_circuit(6, 10, [1=>2, 3=>4, 5=>6, 2=>3, 4=>5, 6=>1])\ndispatch!(qcbm, :random) # initialize the parameters\n\nκ = RBFKernel(0.25, 0:2^6-1)\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);\nopt = ADAM()\n\nfunction train(qcbm, κ, opt, target)\n    history = Float64[]\n    for _ in 1:100\n        push!(history, loss(κ, qcbm, target))\n        ps = parameters(qcbm)\n        Optimise.update!(opt, ps, gradient(qcbm, κ, target))\n        popdispatch!(qcbm, ps)\n    end\n    return history\nend\n\nhistory = train(qcbm, κ, opt, pg)\ntrained_pg = probs(zero_state(nqubits(qcbm)) |> qcbm)\nhistory","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"100-element Array{Float64,1}:\n 0.02085888672070265   \n 0.020103289399926585  \n 0.019373362870860174  \n 0.018668145142127304  \n 0.017987112595049905  \n 0.017329764569132915  \n 0.016695251687198577  \n 0.01608260878117987   \n 0.015491711783889434  \n 0.01492256040334432   \n ⋮                     \n 0.00044559698865723874\n 0.00041836046206456256\n 0.00039229578718767504\n 0.0003676615791212344 \n 0.000343991162652843  \n 0.00032126829010034423\n 0.00029960459321211786\n 0.00027962454156665894\n 0.0002607250059224011","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"And we have the history of training which is","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"\nusing Plots\nfig1 = plot(history; legend=nothing)\ntitle!(\"training history\")\nxlabel!(\"steps\"); ylabel!(\"loss\")","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: )","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"And let's check what we got","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"\nfig2 = plot(1:1<<6, trained_pg; label=\"trained\")\nplot!(fig2, 1:1<<6, pg; label=\"target\")\ntitle!(\"distribution\")\nxlabel!(\"x\"); ylabel!(\"p\")","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: )","category":"page"},{"location":"examples/QCBM/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"So within 50 steps, we got a pretty close estimation of our target distribution!","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"CurrentModule = YaoArrayRegister\nDocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/array_registers/#Array-Registers-1","page":"Array Registers","title":"Array Registers","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"We provide ArrayReg as built in register type for simulations. It is a simple wrapper of a Julia array, e.g on CPU, we use Array by default and on CUDA devices we could use CuArray. You don't have to define your custom array type if the storage is array based.","category":"page"},{"location":"man/array_registers/#Constructors-1","page":"Array Registers","title":"Constructors","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"ArrayReg","category":"page"},{"location":"man/array_registers/#YaoArrayRegister.ArrayReg","page":"Array Registers","title":"YaoArrayRegister.ArrayReg","text":"ArrayReg{B, T, MT <: AbstractMatrix{T}} <: AbstractRegister{B, T}\n\nSimulated full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. B is the batch size, T is the numerical type for each amplitude, it is ComplexF64 by default.\n\n\n\n\n\n","category":"type"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"We define some shortcuts to create simulated quantum states easier:","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"product_state\nzero_state\nrand_state\nuniform_state\noneto\nrepeat","category":"page"},{"location":"man/array_registers/#YaoArrayRegister.product_state","page":"Array Registers","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], bit_str; nbatch=1)\n\nCreate an ArrayReg with bit string literal defined with @bit_str. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(bit\"100\"; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 3/3\n\njulia> product_state(ComplexF32, bit\"101\"; nbatch=2)\nArrayReg{2,Complex{Float32},Array...}\n    active qubits: 3/3\n\n\n\n\n\nproduct_state([T=ComplexF64], total::Int, bit_config::Integer; nbatch=1)\n\nCreate an ArrayReg with bit configuration bit_config, total number of bits total. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(4, 3; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> product_state(4, 0b1001; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> product_state(ComplexF32, 4, 0b101)\nArrayReg{1,Complex{Float32},Array...}\n    active qubits: 4/4\n\nwarning: Warning\nThis interface will not check whether the number of required digits for the bit configuration matches the total number of bits.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.zero_state","page":"Array Registers","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int; nbatch::Int=1)\n\nCreate an ArrayReg with total number of bits n. See also product_state, rand_state, uniform_state.\n\nExamples\n\njulia> zero_state(4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> zero_state(ComplexF32, 4)\nArrayReg{1,Complex{Float32},Array...}\n    active qubits: 4/4\n\njulia> zero_state(ComplexF32, 4; nbatch=3)\nArrayReg{3,Complex{Float32},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.rand_state","page":"Array Registers","title":"YaoArrayRegister.rand_state","text":"rand_state([T=ComplexF64], n::Int; nbatch::Int=1)\n\nCreate a random ArrayReg with total number of qubits n.\n\nExamples\n\njulia> rand_state(4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> rand_state(ComplexF64, 4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> rand_state(ComplexF64, 4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.uniform_state","page":"Array Registers","title":"YaoArrayRegister.uniform_state","text":"uniform_state([T=ComplexF64], n; nbatch=1)\n\nCreate a uniform state: frac12^n sum_k k. This state can also be created by applying H (Hadmard gate) on 0000 state.\n\nExample\n\njulia> uniform_state(4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> uniform_state(ComplexF32, 4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.oneto","page":"Array Registers","title":"YaoArrayRegister.oneto","text":"oneto(r::ArrayReg, n::Int=nqubits(r))\n\nReturns an ArrayReg with 1:n qubits activated.\n\n\n\n\n\noneto(n::Int) -> f(register)\n\nLike oneto(register, n), but the input register is delayed.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#Base.repeat","page":"Array Registers","title":"Base.repeat","text":"repeat(n, x::AbstractBlock[, locs]) -> RepeatedBlock{n}\n\nCreate a RepeatedBlock with total number of qubits n and the block to repeat on given location or on all the locations.\n\nExample\n\nThis will create a repeat block which puts 4 X gates on each location.\n\njulia> repeat(4, X)\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ X gate\n\nYou can also specify the location\n\njulia> repeat(4, X, (1, 2))\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2)\n└─ X gate\n\nBut repeat won't copy the gate, thus, if it is a gate with parameter, e.g a phase(0.1), the parameter will change simultaneously.\n\njulia> g = repeat(4, phase(0.1))\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ phase(0.1)\n\njulia> g.content\nphase(0.1)\n\njulia> g.content.theta = 0.2\n0.2\n\njulia> g\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ phase(0.2)\n\n\n\n\n\nrepeat(x::AbstractBlock, locs)\n\nLazy curried version of repeat.\n\n\n\n\n\nrepeat(r::AbstractRegister, n::Int) -> register\n\nRepeat register r for n times on batch dimension.\n\n\n\n\n\nrepeat(register, n)\n\nCreate an ArrayReg by copying the original register for n times on batch dimension.\n\nExample\n\njulia> repeat(ArrayReg{3}(bit\"101\"), 4)\nArrayReg{12,Complex{Float64},Array...}\n    active qubits: 3/3\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#Properties-1","page":"Array Registers","title":"Properties","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"You can access the storage of an ArrayReg with:","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"state\nstatevec\nrelaxedvec\nhypercubic\nrank3","category":"page"},{"location":"man/array_registers/#YaoArrayRegister.state","page":"Array Registers","title":"YaoArrayRegister.state","text":"state(register::ArrayReg) -> raw array\n\nReturns the raw array storage of register. See also statevec.\n\n\n\n\n\nstate(ρ::DensityMatrix)\n\nReturn the raw state of density matrix ρ.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.statevec","page":"Array Registers","title":"YaoArrayRegister.statevec","text":"statevec(r::ArrayReg) -> array\n\nReturn a state matrix/vector by droping the last dimension of size 1. See also state.\n\nwarning: Warning\nstatevec is not type stable. It may cause performance slow down.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.relaxedvec","page":"Array Registers","title":"YaoArrayRegister.relaxedvec","text":"relaxedvec(r::ArrayReg) -> AbstractArray\n\nReturn a matrix (vector) for B>1 (B=1) as a vector representation of state, with all qubits activated. See also state, statevec.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#BitBasis.hypercubic","page":"Array Registers","title":"BitBasis.hypercubic","text":"hypercubic(A::Array) -> Array\n\nget the hypercubic representation for an array.\n\n\n\n\n\nhypercubic(r::ArrayReg) -> AbstractArray\n\nReturn the hypercubic form (high dimensional tensor) of this register, only active qubits are considered. See also rank3.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.rank3","page":"Array Registers","title":"YaoArrayRegister.rank3","text":"rank3(r::ArrayReg)\n\nReturn the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension). See also rank3.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#Operations-1","page":"Array Registers","title":"Operations","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"We defined basic arithmatics for ArrayReg, besides since we do not garantee normalization for some operations on ArrayReg for simulation, normalize! and  isnormalized is provided to check and normalize the simulated register.","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"normalize!\nisnormalized","category":"page"},{"location":"man/array_registers/#LinearAlgebra.normalize!","page":"Array Registers","title":"LinearAlgebra.normalize!","text":"normalize!(r::ArrayReg)\n\nNormalize the register r in-place by its 2-norm.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.isnormalized","page":"Array Registers","title":"YaoArrayRegister.isnormalized","text":"isnormalized(r::ArrayReg) -> Bool\n\nCheck if the register is normalized.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#Specialized-Instructions-1","page":"Array Registers","title":"Specialized Instructions","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"We define some specialized instruction by specializing instruct! to improve the performance for simulation and dispatch them with multiple dispatch.","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Implemented instruct! is listed below:","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"using YaoArrayRegister, Latexify\n\n## get the method table first\nmtable = methods(instruct!)\n## preprocess the method table, filter out what's in YaoArrayRegister\n\nget_storage_sig(x) = get_storage_sig(x, 2)\nget_storage_sig(x::Method, k) = get_storage_sig(x.sig, k)\nget_storage_sig(x, k) = x.parameters[k]\nget_storage_sig(x::UnionAll, k) = get_storage_sig(x.body, k)\n\nlist = filter(x->get_storage_sig(x) <: AbstractVecOrMat, mtable.ms)\nlist = filter(x->x.module === YaoArrayRegister, list)\n\nregisters = map(list) do x\n    sig = get_storage_sig(x)\n    sig <: AbstractVecOrMat ? \"AbstractVecOrMat\" :\n    sig <: Array ? \"Array\" : string(sig)\nend\n\noperators = map(list) do x\n    sig = get_storage_sig(x, 3)\n    sig <: AbstractMatrix ? string(sig) :\n    sig <: Val ? string(sig.parameters[1]) :\n    string(sig)\nend\n\nnqubits_str = map(list) do x\n    sig = get_storage_sig(x, 4)\n    sig <: Union{Int, Tuple{Int}} ? \"single\" :\n    sig <: NTuple{N, Int} where N ? \"multiple\" : error(\"instruct is not specialized correctly, got $sig\")\nend\n\ncontrol_str = map(list) do x\n    try\n        sig = get_storage_sig(x, 5)\n        sig <: Union{Int, Tuple{Int}} ? \"single\" :\n        sig <: NTuple{N, Int} where N ? \"multiple\" : error(\"instruct is not specialized correctly, got $sig\")\n    catch e\n        if e isa BoundsError\n            return \"none\"\n        end\n    end\nend\n\nfunction make_table(registers, operators, nqubits, controls)\n    N = length(registers)\n    out = Dict(\"registers\"=>[], \"operators\"=>[], \"nqubits\"=>[], \"controls\"=>[])\n\n    count = 0; k = 1; searched = []\n    while count != N\n        if k in searched\n            k = k + 1\n            continue\n        else\n            indices = findall(x->x==operators[k], operators)\n            append!(searched, indices)\n        end\n\n        push!(out[\"operators\"], operators[k])\n        push!(out[\"registers\"], join(unique(registers[indices]), \", \"))\n        push!(out[\"nqubits\"], join(unique(nqubits[indices]), \", \"))\n        push!(out[\"controls\"], join(unique(controls[indices]), \", \"))\n        count += length(indices)\n        k += 1\n    end\n    return out\nend\n\nd = make_table(registers, operators, nqubits_str, control_str)\ndata = hcat(map(x->\"`$x`\", d[\"registers\"]), map(x->\"`$x`\", d[\"operators\"]), d[\"nqubits\"], d[\"controls\"])\nmdtable(data; latex=false, head=[\"registers\", \"operators\", \"nqubits\", \"controls\"])","category":"page"},{"location":"man/array_registers/#Measurement-1","page":"Array Registers","title":"Measurement","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Simulation of measurement is mainly achieved by sampling and projection.","category":"page"},{"location":"man/array_registers/#Sample-1","page":"Array Registers","title":"Sample","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Suppose we want to measure operational subspace, we can first get","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"p(x) = langle xpsirangle^2 = sumlimits_y L(x y )^2","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Then we sample an asim p(x). If we just sample and don't really measure (change wave function), its over.","category":"page"},{"location":"man/array_registers/#Projection-1","page":"Array Registers","title":"Projection","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"psirangle = sum_y L(a y )sqrtp(a) arangle yrangle","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Good! then we can just remove the operational qubit space since x and y spaces are totally decoupled and x is known as in state a, then we get","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"psirangle_r = sum_y l(0 y ) yrangle","category":"page"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"where l = L(a:a, :, :)/sqrt(p(a)).","category":"page"},{"location":"man/array_registers/#Others-1","page":"Array Registers","title":"Others","text":"","category":"section"},{"location":"man/array_registers/#","page":"Array Registers","title":"Array Registers","text":"Modules = [YaoArrayRegister]\nOrder = [:function]","category":"page"},{"location":"man/array_registers/#BitBasis.hypercubic-Tuple{Union{ArrayReg{B,T,MT}, AdjointRegister{B,T,ArrayReg{B,T,MT}}} where MT where T where B}","page":"Array Registers","title":"BitBasis.hypercubic","text":"hypercubic(r::ArrayReg) -> AbstractArray\n\nReturn the hypercubic form (high dimensional tensor) of this register, only active qubits are considered. See also rank3.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#LinearAlgebra.normalize!-Union{Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T}, Tuple{B}} where B","page":"Array Registers","title":"LinearAlgebra.normalize!","text":"normalize!(r::ArrayReg)\n\nNormalize the register r in-place by its 2-norm.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.isnormalized-Tuple{ArrayReg}","page":"Array Registers","title":"YaoArrayRegister.isnormalized","text":"isnormalized(r::ArrayReg) -> Bool\n\nCheck if the register is normalized.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.oneto-Tuple{Int64}","page":"Array Registers","title":"YaoArrayRegister.oneto","text":"oneto(n::Int) -> f(register)\n\nLike oneto(register, n), but the input register is delayed.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.oneto-Union{Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T}, Tuple{B}, Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T,Int64}} where B","page":"Array Registers","title":"YaoArrayRegister.oneto","text":"oneto(r::ArrayReg, n::Int=nqubits(r))\n\nReturns an ArrayReg with 1:n qubits activated.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.product_state-Tuple{BitStr}","page":"Array Registers","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], bit_str; nbatch=1)\n\nCreate an ArrayReg with bit string literal defined with @bit_str. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(bit\"100\"; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 3/3\n\njulia> product_state(ComplexF32, bit\"101\"; nbatch=2)\nArrayReg{2,Complex{Float32},Array...}\n    active qubits: 3/3\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.product_state-Tuple{Int64,Integer}","page":"Array Registers","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], total::Int, bit_config::Integer; nbatch=1)\n\nCreate an ArrayReg with bit configuration bit_config, total number of bits total. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(4, 3; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> product_state(4, 0b1001; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> product_state(ComplexF32, 4, 0b101)\nArrayReg{1,Complex{Float32},Array...}\n    active qubits: 4/4\n\nwarning: Warning\nThis interface will not check whether the number of required digits for the bit configuration matches the total number of bits.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.rand_state-Tuple{Int64}","page":"Array Registers","title":"YaoArrayRegister.rand_state","text":"rand_state([T=ComplexF64], n::Int; nbatch::Int=1)\n\nCreate a random ArrayReg with total number of qubits n.\n\nExamples\n\njulia> rand_state(4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> rand_state(ComplexF64, 4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> rand_state(ComplexF64, 4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.rank3-Union{Tuple{Union{ArrayReg{B,T,MT}, AdjointRegister{B,T,ArrayReg{B,T,MT}}} where MT where T}, Tuple{B}} where B","page":"Array Registers","title":"YaoArrayRegister.rank3","text":"rank3(r::ArrayReg)\n\nReturn the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension). See also rank3.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.relaxedvec-Union{Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T}, Tuple{B}} where B","page":"Array Registers","title":"YaoArrayRegister.relaxedvec","text":"relaxedvec(r::ArrayReg) -> AbstractArray\n\nReturn a matrix (vector) for B>1 (B=1) as a vector representation of state, with all qubits activated. See also state, statevec.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.state-Tuple{ArrayReg}","page":"Array Registers","title":"YaoArrayRegister.state","text":"state(register::ArrayReg) -> raw array\n\nReturns the raw array storage of register. See also statevec.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.state-Tuple{DensityMatrix}","page":"Array Registers","title":"YaoArrayRegister.state","text":"state(ρ::DensityMatrix)\n\nReturn the raw state of density matrix ρ.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.statevec-Tuple{Union{ArrayReg{B,T,MT}, AdjointRegister{B,T,ArrayReg{B,T,MT}}} where MT where T where B}","page":"Array Registers","title":"YaoArrayRegister.statevec","text":"statevec(r::ArrayReg) -> array\n\nReturn a state matrix/vector by droping the last dimension of size 1. See also state.\n\nwarning: Warning\nstatevec is not type stable. It may cause performance slow down.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.uniform_state-Tuple{Int64}","page":"Array Registers","title":"YaoArrayRegister.uniform_state","text":"uniform_state([T=ComplexF64], n; nbatch=1)\n\nCreate a uniform state: frac12^n sum_k k. This state can also be created by applying H (Hadmard gate) on 0000 state.\n\nExample\n\njulia> uniform_state(4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> uniform_state(ComplexF32, 4; nbatch=2)\nArrayReg{2,Complex{Float64},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.zero_state-Tuple{Int64}","page":"Array Registers","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int; nbatch::Int=1)\n\nCreate an ArrayReg with total number of bits n. See also product_state, rand_state, uniform_state.\n\nExamples\n\njulia> zero_state(4)\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 4/4\n\njulia> zero_state(ComplexF32, 4)\nArrayReg{1,Complex{Float32},Array...}\n    active qubits: 4/4\n\njulia> zero_state(ComplexF32, 4; nbatch=3)\nArrayReg{3,Complex{Float32},Array...}\n    active qubits: 4/4\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoBase.fidelity-Union{Tuple{B}, Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T,ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T}} where B","page":"Array Registers","title":"YaoBase.fidelity","text":"fidelity(r1::ArrayReg, r2::ArrayReg)\n\nCalcuate the fidelity between r1 and r2, if r1 or r2 is not pure state (nactive(r) != nqubits(r)), the fidelity is calcuated by purification. See also pure_state_fidelity, purification_fidelity.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoBase.probs-Union{Tuple{DensityMatrix{B,T,MT} where MT<:AbstractArray{T,3}}, Tuple{T}, Tuple{B}} where T where B","page":"Array Registers","title":"YaoBase.probs","text":"probs(ρ)\n\nReturns the probability distribution from a density matrix ρ.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#Base.join-Union{Tuple{Vararg{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T,N} where N}, Tuple{B}} where B","page":"Array Registers","title":"Base.join","text":"join(regs...)\n\nconcat a list of registers regs to a larger register, each register should have the same batch size. See also repeat.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#Base.repeat-Union{Tuple{B}, Tuple{ArrayReg{B,T,MT} where MT<:AbstractArray{T,2} where T,Int64}} where B","page":"Array Registers","title":"Base.repeat","text":"repeat(register, n)\n\nCreate an ArrayReg by copying the original register for n times on batch dimension.\n\nExample\n\njulia> repeat(ArrayReg{3}(bit\"101\"), 4)\nArrayReg{12,Complex{Float64},Array...}\n    active qubits: 3/3\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.contiguous_shape_orders-Tuple{Any,Any}","page":"Array Registers","title":"YaoArrayRegister.contiguous_shape_orders","text":"contiguous_shape_orders(shape, orders)\n\nMerge the shape and orders if the orders are contiguous. Returns the new merged shape and order.\n\nExample\n\njulia> YaoArrayRegister.contiguous_shape_order((2, 3, 4), (1, 2, 3))\n([24], [1])\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.is_order_same-Tuple{Any}","page":"Array Registers","title":"YaoArrayRegister.is_order_same","text":"is_order_same(locs) -> Bool\n\nCheck if the order specified by locs is the same as current order.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.matvec","page":"Array Registers","title":"YaoArrayRegister.matvec","text":"matvec(x::VecOrMat) -> MatOrVec\n\nReturn vector if a matrix is a column vector, else untouched.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.move_ahead-Tuple{Any,Any}","page":"Array Registers","title":"YaoArrayRegister.move_ahead","text":"move_ahead(collection, orders)\n\nMove orders to the beginning of collection.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.mulcol!","page":"Array Registers","title":"YaoArrayRegister.mulcol!","text":"mulcol!(v::AbstractVector, i::Int, f) -> VecOrMat\n\nmultiply col i of v by f inplace.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.mulrow!","page":"Array Registers","title":"YaoArrayRegister.mulrow!","text":"mulrow!(v::AbstractVector, i::Int, f) -> VecOrMat\n\nmultiply row i of v by f inplace.\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.sort_unitary-Union{Tuple{N}, Tuple{AbstractArray{T,2} where T,Tuple{Vararg{Int64,N}}}} where N","page":"Array Registers","title":"YaoArrayRegister.sort_unitary","text":"sort_unitary(U, locations::NTuple{N, Int}) -> U\n\nReturn an sorted unitary operator according to the locations.\n\n\n\n\n\n","category":"method"},{"location":"man/array_registers/#YaoArrayRegister.swapcols!","page":"Array Registers","title":"YaoArrayRegister.swapcols!","text":"swapcols!(v::VecOrMat, i::Int, j::Int[, f1, f2]) -> VecOrMat\n\nswap col i and col j of v inplace, with f1, f2 factors applied on i and j (before swap).\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.swaprows!","page":"Array Registers","title":"YaoArrayRegister.swaprows!","text":"swaprows!(v::VecOrMat, i::Int, j::Int[, f1, f2]) -> VecOrMat\n\nswap row i and row j of v inplace, with f1, f2 factors applied on i and j (before swap).\n\n\n\n\n\n","category":"function"},{"location":"man/array_registers/#YaoArrayRegister.u1rows!","page":"Array Registers","title":"YaoArrayRegister.u1rows!","text":"u1rows!(state::VecOrMat, i::Int, j::Int, a, b, c, d) -> VecOrMat\n\napply u1 on row i and row j of state inplace.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"DocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/blocks/#Blocks-1","page":"Blocks","title":"Blocks","text":"","category":"section"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Blocks are the basic building blocks of a quantum circuit in Yao. It simply means a quantum operator, thus, all the blocks have matrices in principal and one can get its matrix by mat. The basic blocks required to build an arbitrary quantum circuit is defined in the component package YaoBlocks.","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Block Tree serves as an intermediate representation for Yao to analysis, optimize the circuit, then it will be lowered to instructions like for simulations, blocks will be lowered to instruct! calls.","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"The structure of blocks is the same with a small type system, it consists of two basic kinds of blocks: CompositeBlock (like composite types), and PrimitiveBlock (like primitive types). By combining these two kinds of blocks together, we'll be able to construct a quantum circuit and represent it in a tree data structure.","category":"page"},{"location":"man/blocks/#Primitive-Blocks-1","page":"Blocks","title":"Primitive Blocks","text":"","category":"section"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Primitive blocks are subtypes of PrimitiveBlock, they are the leaf nodes in a block tree, thus primitive types do not have subtypes.","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"We provide the following primitive blocks:","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Modules = [YaoBlocks]\nFilter = t ->(t isa Type && t <: YaoBlocks.PrimitiveBlock)","category":"page"},{"location":"man/blocks/#YaoBlocks.GeneralMatrixBlock","page":"Blocks","title":"YaoBlocks.GeneralMatrixBlock","text":"GeneralMatrixBlock{M, N, T, MT} <: PrimitiveBlock{N, T}\n\nGeneral matrix gate wraps a matrix operator to quantum gates. This is the most general form of a quantum gate. M is the hilbert dimension (first dimension), N is the hilbert dimension (second dimension) of current quantum state. For most quantum gates, we have M = N.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.Measure","page":"Blocks","title":"YaoBlocks.Measure","text":"Measure{N, K, OT} <: PrimitiveBlock{N, Bool}\nMeasure(n::Int; operator=ComputationalBasis(), locs=1:n, collapseto=nothing, remove=false)\n\nMeasure operator.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.PhaseGate","page":"Blocks","title":"YaoBlocks.PhaseGate","text":"PhiGate\n\nGlobal phase gate.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.PrimitiveBlock","page":"Blocks","title":"YaoBlocks.PrimitiveBlock","text":"PrimitiveBlock{N, T} <: AbstractBlock{N, T}\n\nAbstract type that all primitive block will subtype from. A primitive block is a concrete block who can not be decomposed into other blocks. All composite block can be decomposed into several primitive blocks.\n\nnote: Note\nsubtype for primitive block with parameter should implement hash and == method to enable key value cache.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.ReflectGate","page":"Blocks","title":"YaoBlocks.ReflectGate","text":"ReflectGate{N, T, Tr} <: PrimitiveBlock{N, T}\n\nReflection operator to target state psi.\n\nDefinition\n\nψ  2 ss - 1\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.ReflectGate-Tuple{AbstractArray{#s13,1} where #s13<:Complex}","page":"Blocks","title":"YaoBlocks.ReflectGate","text":"ReflectGate(r::AbstractVector)\n\nCreate a ReflectGate with a quantum state vector v.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.ReflectGate-Union{Tuple{ArrayReg{1,T,MT} where MT<:AbstractArray{T,2}}, Tuple{T}} where T","page":"Blocks","title":"YaoBlocks.ReflectGate","text":"ReflectGate(r::ArrayReg{1})\n\nCreate a ReflectGate with a quantum register r.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.RotationGate","page":"Blocks","title":"YaoBlocks.RotationGate","text":"RotationGate{N, T, GT <: AbstractBlock{N, Complex{T}}} <: PrimitiveBlock{N, Complex{T}}\n\nRotationGate, with GT both hermitian and isreflexive.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.ShiftGate","page":"Blocks","title":"YaoBlocks.ShiftGate","text":"ShiftGate <: PrimitiveBlock\n\nPhase shift gate.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.TimeEvolution","page":"Blocks","title":"YaoBlocks.TimeEvolution","text":"TimeEvolution{N, TT, GT} <: PrimitiveBlock{N, ComplexF64}\n\nTimeEvolution, where GT is block type. input matrix should be hermitian.\n\n!!!note:     TimeEvolution contructor check hermicity of the input block by default, but sometimes it can be slow. Turn off the check manually by specifying optional parameter check_hermicity = false.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.TimeEvolution-Tuple{AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.TimeEvolution","text":"TimeEvolution(H, dt[; tol::Real=1e-7])\n\nCreate a TimeEvolution block with Hamiltonian H and time step dt. The TimeEvolution block will use Krylove based expv to calculate time propagation.\n\nOptional keywords are tolerance tol (default is 1e-7) TimeEvolution block can also be used for imaginary time evolution if dt is complex.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#Composite-Blocks-1","page":"Blocks","title":"Composite Blocks","text":"","category":"section"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Composite blocks are subtypes of CompositeBlock, they are the composition of blocks.","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"We provide the following composite blocks:","category":"page"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Modules = [YaoBlocks]\nFilter = t -> t isa Type && t <: YaoBlocks.CompositeBlock","category":"page"},{"location":"man/blocks/#YaoBlocks.AbstractContainer","page":"Blocks","title":"YaoBlocks.AbstractContainer","text":"AbstractContainer{BT, N, T} <: CompositeBlock{N, T}\n\nAbstract type for container block. Container blocks are blocks contain a single block. Container block should have a\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.CachedBlock","page":"Blocks","title":"YaoBlocks.CachedBlock","text":"CachedBlock{ST, BT, N, T} <: TagBlock{BT, N, T}\n\nA label type that tags an instance of type BT. It forwards every methods of the block it contains, except mat and apply!, it will cache the matrix form whenever the program has.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.ChainBlock","page":"Blocks","title":"YaoBlocks.ChainBlock","text":"ChainBlock{N, T} <: CompositeBlock{N, T}\n\nChainBlock is a basic construct tool to create user defined blocks horizontically. It is a Vector like composite type.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.CompositeBlock","page":"Blocks","title":"YaoBlocks.CompositeBlock","text":"CompositeBlock{N, T} <: AbstractBlock{N, T}\n\nAbstract supertype which composite blocks will inherit from. Composite blocks are blocks composited from other AbstractBlocks, thus it is a AbstractBlock as well.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.Concentrator","page":"Blocks","title":"YaoBlocks.Concentrator","text":"Concentrator{N, T, BT <: AbstractBlock} <: AbstractContainer{BT, N, T}\n\nconcentrates serveral lines together in the circuit, and expose it to other blocks.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.Daggered","page":"Blocks","title":"YaoBlocks.Daggered","text":"Daggered{N, T, BT} <: TagBlock{N, T}\n\nWrapper block allowing to execute the inverse of a block of quantum circuit.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.KronBlock","page":"Blocks","title":"YaoBlocks.KronBlock","text":"KronBlock{N, T, MT<:AbstractBlock} <: CompositeBlock{N, T}\n\ncomposite block that combine blocks by kronecker product.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.PauliString-Tuple{Array{T,1} where T}","page":"Blocks","title":"YaoBlocks.PauliString","text":"PauliString(list::Vector)\n\nCreate a PauliString from a list of Pauli gates.\n\nExample\n\njulia> PauliString([X, Y, Z])\nnqubits: 3, datatype: Complex{Float64}\nPauliString\n├─ X gate\n├─ Y gate\n└─ Z gate\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.PauliString-Union{Tuple{Vararg{Union{I2Gate{T}, XGate{T}, YGate{T}, ZGate{T}},N} where N}, Tuple{T}} where T","page":"Blocks","title":"YaoBlocks.PauliString","text":"PauliString(xs::PauliGate...)\n\nCreate a PauliString from some Pauli gates.\n\nExample\n\njulia> PauliString(X, Y, Z)\nnqubits: 3, datatype: Complex{Float64}\nPauliString\n├─ X gate\n├─ Y gate\n└─ Z gate\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.PutBlock","page":"Blocks","title":"YaoBlocks.PutBlock","text":"PutBlock <: AbstractContainer\n\nType for putting a block at given locations.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.RepeatedBlock","page":"Blocks","title":"YaoBlocks.RepeatedBlock","text":"RepeatedBlock <: AbstractContainer\n\nRepeat the same block on given locations.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.Roller","page":"Blocks","title":"YaoBlocks.Roller","text":"Roller{N, T, BT <: Tuple} <: CompositeBlock{N, T}\n\nRoller block.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#YaoBlocks.TagBlock","page":"Blocks","title":"YaoBlocks.TagBlock","text":"TagBlock{BT, N, T} <: AbstractContainer{BT, N, T}\n\nTagBlock is a special kind of Container block, it forwards most of the methods but tag the block with some extra information.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks/#APIs-1","page":"Blocks","title":"APIs","text":"","category":"section"},{"location":"man/blocks/#","page":"Blocks","title":"Blocks","text":"Modules = [YaoBlocks]\nOrder = [:function, :macro]","category":"page"},{"location":"man/blocks/#Base.kron-Tuple{Int64,Vararg{Pair{Int64,#s35} where #s35<:AbstractBlock,N} where N}","page":"Blocks","title":"Base.kron","text":"kron(n, blocks::Pair{Int, <:AbstractBlock}...)\n\nReturn a KronBlock, with total number of qubits n and pairs of blocks.\n\nExample\n\nUse kron to construct a KronBlock, it will put an X gate on the 1st qubit, and a Y gate on the 3rd qubit.\n\njulia> kron(4, 1=>X, 3=>Y)\nnqubits: 4, datatype: Complex{Float64}\nkron\n├─ 1=>X gate\n└─ 3=>Y gate\n\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#Base.kron-Tuple{Vararg{AbstractBlock,N} where N}","page":"Blocks","title":"Base.kron","text":"kron(blocks::AbstractBlock...)\nkron(n, itr)\n\nReturn a KronBlock, with total number of qubits n, and blocks should use all the locations on n wires in quantum circuits.\n\nExample\n\nYou can use kronecker product to composite small blocks to a large blocks.\n\njulia> kron(X, Y, Z, Z)\nnqubits: 4, datatype: Complex{Float64}\nkron\n├─ 1=>X gate\n├─ 2=>Y gate\n├─ 3=>Z gate\n└─ 4=>Z gate\n\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#Base.kron-Tuple{Vararg{Pair{Int64,#s35} where #s35<:AbstractBlock,N} where N}","page":"Blocks","title":"Base.kron","text":"kron(blocks...) -> f(n)\nkron(itr) -> f(n)\n\nReturn a lambda, which will take the total number of qubits as input.\n\nExample\n\nIf you don't know the number of qubit yet, or you are just too lazy, it is fine.\n\njulia> kron(put(1=>X) for _ in 1:2)\n(n -> kron(n, (n  ->  put(n, 1 => X gate)), (n  ->  put(n, 1 => X gate))))\n\njulia> kron(X for _ in 1:2)\nnqubits: 2, datatype: Complex{Float64}\nkron\n├─ 1=>X gate\n└─ 2=>X gate\n\njulia> kron(1=>X, 3=>Y)\n(n -> kron(n, 1 => X gate, 3 => Y gate))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#Base.repeat-Tuple{AbstractBlock,Any}","page":"Blocks","title":"Base.repeat","text":"repeat(x::AbstractBlock, locs)\n\nLazy curried version of repeat.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#Base.repeat-Tuple{Int64,AbstractBlock,Vararg{Int64,N} where N}","page":"Blocks","title":"Base.repeat","text":"repeat(n, x::AbstractBlock[, locs]) -> RepeatedBlock{n}\n\nCreate a RepeatedBlock with total number of qubits n and the block to repeat on given location or on all the locations.\n\nExample\n\nThis will create a repeat block which puts 4 X gates on each location.\n\njulia> repeat(4, X)\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ X gate\n\nYou can also specify the location\n\njulia> repeat(4, X, (1, 2))\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2)\n└─ X gate\n\nBut repeat won't copy the gate, thus, if it is a gate with parameter, e.g a phase(0.1), the parameter will change simultaneously.\n\njulia> g = repeat(4, phase(0.1))\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ phase(0.1)\n\njulia> g.content\nphase(0.1)\n\njulia> g.content.theta = 0.2\n0.2\n\njulia> g\nnqubits: 4, datatype: Complex{Float64}\nrepeat on (1, 2, 3, 4)\n└─ phase(0.2)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.Rx-Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat","page":"Blocks","title":"YaoBlocks.Rx","text":"Rx(theta)\n\nReturn a RotationGate on X axis.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.Ry-Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat","page":"Blocks","title":"YaoBlocks.Ry","text":"Ry(theta)\n\nReturn a RotationGate on Y axis.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.Rz-Union{Tuple{T}, Tuple{T}} where T<:AbstractFloat","page":"Blocks","title":"YaoBlocks.Rz","text":"Rz(theta)\n\nReturn a RotationGate on Z axis.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.apply!-Tuple{AbstractRegister,AbstractBlock}","page":"Blocks","title":"YaoBlocks.apply!","text":"apply!(register, block)\n\nApply a block (of quantum circuit) to a quantum register.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.applymatrix-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.applymatrix","text":"applymatrix(g::AbstractBlock) -> Matrix\n\nTransform the apply! function of specific block to dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.cache_key-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.cache_key","text":"cache_key(block)\n\nReturns the key that identify the matrix cache of this block. By default, we use the returns of parameters as its key.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.cache_type-Tuple{Type{#s13} where #s13<:AbstractBlock}","page":"Blocks","title":"YaoBlocks.cache_type","text":"cache_type(::Type) -> DataType\n\nReturn the element type that a CacheFragment will use.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.chain-Tuple{Int64}","page":"Blocks","title":"YaoBlocks.chain","text":"chain([T=ComplexF64], n)\n\nReturn an empty ChainBlock which can be used like a list of blocks.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.chain-Tuple{}","page":"Blocks","title":"YaoBlocks.chain","text":"chain()\n\nReturn an lambda n->chain(n).\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.chain-Union{Tuple{Vararg{AbstractBlock{N,T} where T,N1} where N1}, Tuple{N}} where N","page":"Blocks","title":"YaoBlocks.chain","text":"chain(blocks...)\n\nReturn a ChainBlock which chains a list of blocks with same nqubits and datatype. If there is lazy evaluated block in blocks, chain can infer the number of qubits and create an instance itself.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.chcontent-Tuple{AbstractContainer,Any}","page":"Blocks","title":"YaoBlocks.chcontent","text":"chcontent(x, blk)\n\nCreate a similar block of x and change its content to blk.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.chsubblocks-Tuple{AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.chsubblocks","text":"chsubblocks(composite_block, itr)\n\nChange the sub-blocks of a CompositeBlock with given iterator itr.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.cnot-Tuple{Int64,Any,Int64}","page":"Blocks","title":"YaoBlocks.cnot","text":"cnot(n, ctrl_locs, location)\n\nReturn a speical ControlBlock, aka CNOT gate with number of active qubits n and locs of control qubits ctrl_locs, and location of X gate.\n\nExample\n\njulia> cnot(3, (2, 3), 1)\nnqubits: 3, datatype: Complex{Float64}\ncontrol(2, 3)\n└─ (1,) X gate\n\njulia> cnot(2, 1)\n(n -> cnot(n, 2, 1))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.collect_blocks-Union{Tuple{T}, Tuple{Type{T},AbstractBlock}} where T<:AbstractBlock","page":"Blocks","title":"YaoBlocks.collect_blocks","text":"collect_blocks(block_type, root)\n\nReturn a ChainBlock with all block of block_type in root.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.concentrate-Tuple{AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.concentrate","text":"concentrate(block, locs) -> f(n)\n\nLazy curried version of concentrate.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.concentrate-Tuple{Int64,AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.concentrate","text":"concentrate(n, block, locs)\n\nCreate a Concentrator block with total number of current active qubits n, which concentrates given wire location together to length(locs) active qubits, and relax the concentration afterwards.\n\nExample\n\nConcentrator is equivalent to put a block on given position mathematically, but more efficient and convenient for large blocks.\n\njulia> r = rand_state(3)\nArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 3/3\n\njulia> apply!(copy(r), concentrate(X, 1)) ≈ apply!(copy(r), put(1=>X))\ntrue\n\nIt works for in-contigious locations as well\n\njulia> r = rand_state(4)\nArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 4/4\n\njulia> cc = concentrate(4, kron(X, Y), (1, 3))\nnqubits: 4, datatype: Complex{Float64}\nConcentrator: (1, 3)\n└─ kron\n   ├─ 1=>X gate\n   └─ 2=>Y gate\n\njulia> pp = chain(4, put(1=>X), put(3=>Y))\nnqubits: 4, datatype: Complex{Float64}\nchain\n├─ put on (1)\n│  └─ X gate\n└─ put on (3)\n   └─ Y gate\n\njulia> apply!(copy(r), cc) ≈ apply!(copy(r), pp)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.content-Tuple{AbstractContainer}","page":"Blocks","title":"YaoBlocks.content","text":"content(x)\n\nReturns the content of x.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.control-Tuple{Any,Pair}","page":"Blocks","title":"YaoBlocks.control","text":"control(ctrl_locs, target) -> f(n)\n\nReturn a lambda that takes the number of total active qubits as input. See also control.\n\nExample\n\njulia> control((2, 3), 1=>X)\n(n -> control(n, (2, 3), 1 => X gate))\n\njulia> control(2, 1=>X)\n(n -> control(n, 2, 1 => X gate))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.control-Tuple{Int64,Any,Pair}","page":"Blocks","title":"YaoBlocks.control","text":"control(n, ctrl_locs, target)\n\nReturn a ControlBlock with number of active qubits n and control locs ctrl_locs, and control target in Pair.\n\nExample\n\njulia> control(4, (1, 2), 3=>X)\nnqubits: 4, datatype: Complex{Float64}\ncontrol(1, 2)\n└─ (3,) X gate\n\njulia> control(4, 1, 3=>X)\nnqubits: 4, datatype: Complex{Float64}\ncontrol(1)\n└─ (3,) X gate\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.control-Tuple{Pair}","page":"Blocks","title":"YaoBlocks.control","text":"control(target) -> f(ctrl_locs)\n\nReturn a lambda that takes a Tuple of control qubits locs as input. See also control.\n\nExample\n\njulia> control(1=>X)\n(ctrl_locs -> control(ctrl_locs, 1 => X gate))\n\njulia> control((2, 3) => ConstGate.CNOT)\n(ctrl_locs -> control(ctrl_locs, (2, 3) => CNOT gate))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.control-Tuple{Vararg{Int64,N} where N}","page":"Blocks","title":"YaoBlocks.control","text":"control(ctrl_locs::Int...) -> f(target)\n\nReturn a lambda that takes a Pair of control target as input. See also control.\n\nExample\n\njulia> control(1, 2)\n(target -> control((1, 2), target))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.dispatch!-Tuple{Union{Nothing, Function},AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.dispatch!","text":"dispatch!(x::AbstractBlock, collection)\n\nDispatch parameters in collection to block tree x.\n\nnote: Note\nit will try to dispatch the parameters in collection first.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.expect-Union{Tuple{B}, Tuple{AbstractBlock,DensityMatrix{B,T,MT} where MT<:AbstractArray{T,3} where T}} where B","page":"Blocks","title":"YaoBlocks.expect","text":"expect(op::AbstractBlock, reg::AbstractRegister{B}) -> Vector\nexpect(op::AbstractBlock, dm::DensityMatrix{B}) -> Vector\n\nexpectation value of an operator.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.getiparams-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.getiparams","text":"getiparams(block)\n\nReturns the intrinsic parameters of node block, default is an empty tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.iparams_eltype-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.iparams_eltype","text":"iparams_eltype(block)\n\nReturn the element type of getiparams.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.mat-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.mat","text":"mat(blk)\n\nReturns the matrix form of given block.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.matblock-Tuple{AbstractArray{T,2} where T}","page":"Blocks","title":"YaoBlocks.matblock","text":"matblock(m::AbstractMatrix)\n\nCreate a GeneralMatrixBlock with a matrix m.\n\nExample\n\n\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.matblock-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.matblock","text":"matblock(m::AbstractMatrix)\n\nCreate a GeneralMatrixBlock with a matrix m.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.mathgate-Tuple{Any}","page":"Blocks","title":"YaoBlocks.mathgate","text":"mathgate(f; nbits[, bview=BitBasis.bint])\n\nCreate a MathGate with a math function f and number of bits. You can select different kinds of view which this MathGate will be applied on. Possible values are BitBasis.bint, BitBasis.bint_r, BitBasis.bfloat, BitBasis.bfloat_r.\n\nmathgate(f; bview=BitBasis.bint) -> f(n)\n\nLazy curried version of mathgate.\n\nExample\n\nWe can make a classical toffoli gate on quantum register.\n\njulia> r = ArrayReg(bit\"110\")\nArrayReg{1, Complex{Float64}, Array...}\n    active qubits: 3/3\n\njulia> function toffli(b::BitStr)\n           t = @inbounds b[1] ⊻ (b[3] & b[2])\n           return @inbounds bit_literal(t, b[2], b[3])\n       end\ntoffli (generic function with 1 method)\n\njulia> g = mathgate(toffli; nbits=3)\nmathgate(toffli; nbits=3, bview=bint)\n\njulia> apply!(r, g) == ArrayReg(bit\"111\")\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.niparams-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.niparams","text":"nparameters(block) -> Int\n\nReturn number of parameters in block. See also nparameters.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.occupied_locs-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.occupied_locs","text":"occupied_locs(x)\n\nReturn an iterator of occupied locations of x.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.parameters!-Tuple{Any,AbstractBlock}","page":"Blocks","title":"YaoBlocks.parameters!","text":"parameters!(out, block)\n\nAppend all the parameters contained in block tree with given root block to out.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.parameters-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.parameters","text":"parameters(block)\n\nReturns all the parameters contained in block tree with given root block.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.parameters_eltype-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.parameters_eltype","text":"parameters_eltype(x)\n\nReturn the element type of parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.phase-Tuple{AbstractFloat}","page":"Blocks","title":"YaoBlocks.phase","text":"phase(theta)\n\nReturns a global phase gate.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.popdispatch!-Tuple{AbstractBlock,Array{T,1} where T}","page":"Blocks","title":"YaoBlocks.popdispatch!","text":"popdispatch!(block, list)\n\nPop the first nparameters parameters of list, then dispatch them to the block tree block. See also dispatch!.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.popdispatch!-Tuple{Function,AbstractBlock,Array{T,1} where T}","page":"Blocks","title":"YaoBlocks.popdispatch!","text":"popdispatch!(f, block, list)\n\nPop the first nparameters parameters of list, map them with a function f, then dispatch them to the block tree block. See also dispatch!.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.postwalk-Tuple{Union{Function, Type},AbstractBlock}","page":"Blocks","title":"YaoBlocks.postwalk","text":"postwalk(f, src::AbstractBlock)\n\nWalk the tree and call f after the children are visited.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.prewalk-Tuple{Union{Function, Type},AbstractBlock}","page":"Blocks","title":"YaoBlocks.prewalk","text":"prewalk(f, src::AbstractBlock)\n\nWalk the tree and call f once the node is visited.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.print_tree","page":"Blocks","title":"YaoBlocks.print_tree","text":"print_tree(io, root, node[, depth=1, active_levels=()]; kwargs...)\n\nPrint the block tree.\n\nKeywords\n\nmaxdepth: max tree depth to print\ncharset: default is ('├','└','│','─'). See also BlockTreeCharSet.\ntitle: control whether to print the title, true or false, default is true\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#YaoBlocks.print_tree-Tuple{Any}","page":"Blocks","title":"YaoBlocks.print_tree","text":"print_tree([io=stdout], root)\n\nPrint the block tree.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.projector-Tuple{Any}","page":"Blocks","title":"YaoBlocks.projector","text":"projector(x)\n\nReturn projector on 0 or projector on 1.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.put-Tuple{Pair}","page":"Blocks","title":"YaoBlocks.put","text":"put(pair) -> f(n)\n\nLazy curried version of put.\n\nExample\n\njulia> put(1=>X)\n(n -> put(n, 1 => X gate))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.put-Union{Tuple{M}, Tuple{Int64,Pair{Tuple{Vararg{Int64,M}},#s35} where #s35<:AbstractBlock}} where M","page":"Blocks","title":"YaoBlocks.put","text":"put(total::Int, pair)\n\nCreate a PutBlock with total number of active qubits, and a pair of location and block to put on.\n\nExample\n\njulia> put(4, 1=>X)\nnqubits: 4, datatype: Complex{Float64}\nput on (1)\n└─ X gate\n\nIf you want to put a multi-qubit gate on specific locations, you need to write down all possible locations.\n\njulia> put(4, (1, 3)=>kron(X, Y))\nnqubits: 4, datatype: Complex{Float64}\nput on (1, 3)\n└─ kron\n   ├─ 1=>X gate\n   └─ 2=>Y gate\n\nThe outter locations creates a scope which make it seems to be a contiguous two qubits for the block inside PutBlock.\n\ntips: Tips\nIt is better to use concentrate instead of put for large blocks, since put will use the matrix of its contents directly instead of making use of what's in it. put is more efficient for small blocks.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.reflect-Tuple{AbstractArray{#s13,1} where #s13<:Complex}","page":"Blocks","title":"YaoBlocks.reflect","text":"reflect(v::AbstractVector{<:Complex})\n\nCreate a ReflectGate with an quantum state vector v.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.reflect-Tuple{ArrayReg}","page":"Blocks","title":"YaoBlocks.reflect","text":"reflect(r::ArrayReg)\n\nCreate a ReflectGate with an ArrayReg.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.roll-Tuple{Int64,Vararg{Any,N} where N}","page":"Blocks","title":"YaoBlocks.roll","text":"roll(n, blocks...)\n\nReturn a Roller with total number of active qubits.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.rot-Tuple{AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.rot","text":"rot(U, theta)\n\nReturn a RotationGate on U axis.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.setiparams!-Tuple{AbstractBlock,Vararg{Any,N} where N}","page":"Blocks","title":"YaoBlocks.setiparams!","text":"setiparams!(block, itr)\nsetiparams!(block, params...)\n\nSet the parameters of block.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.setiparams!-Tuple{Function,AbstractBlock,Any}","page":"Blocks","title":"YaoBlocks.setiparams!","text":"setiparams(f, block, collection)\n\nSet parameters of block to the value in collection mapped by f.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.setiparams!-Tuple{Function,AbstractBlock,Symbol}","page":"Blocks","title":"YaoBlocks.setiparams!","text":"setiparams(f, block, symbol)\n\nSet the parameters to a given symbol, which can be :zero, :random.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.shift-Tuple{AbstractFloat}","page":"Blocks","title":"YaoBlocks.shift","text":"shift(θ)\n\nReturns a shift gate.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.simplify-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.simplify","text":"simplify(block[; rules=__default_simplification_rules__])\n\nSimplify a block tree accroding to given rules, default to use __default_simplification_rules__.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.subblocks-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.subblocks","text":"subblocks(x)\n\nReturns an iterator of the sub-blocks of a composite block. Default is empty.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.swap-Tuple{Int64,Int64,Int64}","page":"Blocks","title":"YaoBlocks.swap","text":"swap([T=ComplexF64], n, loc1, loc2)\n\nReturn a n-qubit Swap gate which swap loc1 and loc2.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.swap-Tuple{Int64,Int64}","page":"Blocks","title":"YaoBlocks.swap","text":"swap(loc1, loc2) -> f(n)\n\nReturn a lambda that takes the total number of active qubits as input. See also swap, Swap.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.@mathgate","page":"Blocks","title":"YaoBlocks.@mathgate","text":"@mathgate f <nbits> <bview=bint>\n\nCreate a MathGate with a math function f and number of bits nbits, binary view bview. Unlike mathgate, f will be automatically converted to a more legible form.\n\nExample\n\njulia> @mathgate x->x + 0b11 nbits=4\nmathgate((x -> x + 0x03); nbits=4, bview=bint)\n\n\n\n\n\n","category":"macro"},{"location":"man/blocks/#Base.:|>-Tuple{AbstractRegister,AbstractBlock}","page":"Blocks","title":"Base.:|>","text":"|>(register, blk)\n\nPipe operator for quantum circuits.\n\nExample\n\njulia> ArrayReg(bit\"0\") |> X |> Y\n\nwarning: Warning\n|> is equivalent to apply!, which means it has side effects. You need to copy original register, if you do not want to change it in-place.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#LinearAlgebra.opnorm","page":"Blocks","title":"LinearAlgebra.opnorm","text":"opnorm(A::BlockMap, p::Real=2)\n\nopnorm for quantum circuit blocks.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#YaoBlocks.cunmat","page":"Blocks","title":"YaoBlocks.cunmat","text":"cunmat(nbit::Int, cbits::NTuple{C, Int}, cvals::NTuple{C, Int}, U0::AbstractMatrix, locs::NTuple{M, Int}) where {C, M} -> AbstractMatrix\n\ncontrol-unitary matrix\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#YaoBlocks.decode_sign-Tuple{Vararg{Int64,N} where N}","page":"Blocks","title":"YaoBlocks.decode_sign","text":"decode_sign(ctrls...)\n\nDecode signs into control sequence on control or inversed control.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.getcol-Tuple{Union{SparseMatrixCSC{Tv,Ti}, SSparseMatrixCSC{Tv,Ti,NNZ,NP} where NP where NNZ} where Ti where Tv,Int64}","page":"Blocks","title":"YaoBlocks.getcol","text":"getcol(csc::SDparseMatrixCSC, icol::Int) -> (View, View)\n\nget specific col of a CSC matrix, returns a slice of (rowval, nzval)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.print_annotation-Tuple{IO,Any,Any,Any,Any}","page":"Blocks","title":"YaoBlocks.print_annotation","text":"print_annotation(io, root, node, child, k)\n\nPrint the annotation of k-th child of node, aka the k-th element of subblocks(node).\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.print_prefix-Tuple{IO,Any,Any,Any}","page":"Blocks","title":"YaoBlocks.print_prefix","text":"print_prefix(io, depth, charset, active_levels)\n\nprint prefix of a tree node in a single line.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.print_title-Tuple{IO,AbstractBlock}","page":"Blocks","title":"YaoBlocks.print_title","text":"print_title(io, block)\n\nPrint the title of given block of an AbstractBlock.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.setcol!-Tuple{SparseArrays.SparseMatrixCSC,Int64,AbstractArray{T,1} where T,Any}","page":"Blocks","title":"YaoBlocks.setcol!","text":"setcol!(csc::SparseMatrixCSC, icol::Int, rowval::AbstractVector, nzval) -> SparseMatrixCSC\n\nset specific col of a CSC matrix\n\n\n\n\n\n","category":"method"},{"location":"man/blocks/#YaoBlocks.u1ij!","page":"Blocks","title":"YaoBlocks.u1ij!","text":"u1ij!(target, i, j, a, b, c, d)\n\nsingle u1 matrix into a target matrix.\n\nnote: Note\nFor coo, we take an additional parameter     * ptr: starting position to store new data.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#YaoBlocks.unmat-Tuple{Int64,AbstractArray{T,2} where T,Tuple{Vararg{T,N}} where T where N}","page":"Blocks","title":"YaoBlocks.unmat","text":"unmat(nbit::Int, U::AbstractMatrix, locs::NTuple) -> AbstractMatrix\n\nReturn the matrix representation of putting matrix at locs.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#","page":"Base","title":"Base","text":"DocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/base/#Base-1","page":"Base","title":"Base","text":"","category":"section"},{"location":"man/base/#","page":"Base","title":"Base","text":"The Base module of Yao is defined in YaoBase.jl, it provides:","category":"page"},{"location":"man/base/#","page":"Base","title":"Base","text":"the basic abstract register and its interface\nquantum information related math functions\n@interface macro for drier interface definition in Yao ecosystem\ncustom errors and assertion handling\ngeneral properties, e.g ishermitian, isunitary, etc.\ncommon constants in quantum information","category":"page"},{"location":"man/base/#Math-Functions-1","page":"Base","title":"Math Functions","text":"","category":"section"},{"location":"man/base/#","page":"Base","title":"Base","text":"Modules = [YaoBase]\nPages = [\"utils/math.jl\"]","category":"page"},{"location":"man/base/#YaoBase.autostatic-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}","page":"Base","title":"YaoBase.autostatic","text":"autostatic(A)\n\nStaticize dynamic array A by a constant STATIC_THRESHOLD.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.batch_normalize","page":"Base","title":"YaoBase.batch_normalize","text":"batch_normalize\n\nnormalize a batch of vector.\n\n\n\n\n\n","category":"function"},{"location":"man/base/#YaoBase.batch_normalize!","page":"Base","title":"YaoBase.batch_normalize!","text":"batch_normalize!(matrix)\n\nnormalize a batch of vector.\n\n\n\n\n\n","category":"function"},{"location":"man/base/#YaoBase.density_fidelity-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Base","title":"YaoBase.density_fidelity","text":"density_fidelity(ρ1, ρ2)\n\nGeneral fidelity (including mixed states) between two density matrix for qubits.\n\nDefinition\n\nF(ρ σ)^2 = tr(ρσ) + 2 sqrtdet(ρ)det(σ)\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.general_c1_gates-Union{Tuple{Tp}, Tuple{Tg}, Tuple{Int64,Tp,Int64,Array{Tg,1},Array{Int64,1}}} where Tp<:(AbstractArray{T,2} where T) where Tg<:(AbstractArray{T,2} where T)","page":"Base","title":"YaoBase.general_c1_gates","text":"general_c1_gates(num_bit::Int, projector::AbstractMatrix, cbit::Int, gates::Vector{AbstractMatrix}, locs::Vector{Int}) -> AbstractMatrix\n\ngeneral (low performance) construction method for control gate on different lines.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.general_controlled_gates-Tuple{Int64,Array{#s15,1} where #s15<:(AbstractArray{T,2} where T),Array{Int64,1},Array{#s14,1} where #s14<:(AbstractArray{T,2} where T),Array{Int64,1}}","page":"Base","title":"YaoBase.general_controlled_gates","text":"general_controlled_gates(num_bit::Int, projectors::Vector{Tp}, cbits::Vector{Int}, gates::Vector{AbstractMatrix}, locs::Vector{Int}) -> AbstractMatrix\n\nReturn general multi-controlled gates in hilbert space of num_bit qubits,\n\nprojectors are often chosen as P0 and P1 for inverse-Control and Control at specific position.\ncbits should have the same length as projectors, specifing the controling positions.\ngates are a list of controlled single qubit gates.\nlocs should have the same length as gates, specifing the gates positions.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.hilbertkron-Tuple{Int64,Array{#s16,1} where #s16<:(AbstractArray{T,2} where T),Array{Int64,1}}","page":"Base","title":"YaoBase.hilbertkron","text":"hilbertkron(num_bit::Int, gates::Vector{AbstractMatrix}, locs::Vector{Int}) -> AbstractMatrix\n\nReturn general kronecher product form of gates in Hilbert space of num_bit qubits.\n\ngates are a list of matrices.\nstart_locs should have the same length as gates, specifing the gates starting positions.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.linop2dense-Tuple{Function,Int64}","page":"Base","title":"YaoBase.linop2dense","text":"linop2dense([T=ComplexF64], linear_map!::Function, n::Int) -> Matrix\n\nReturns the dense matrix representation given linear map function.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.nucnorm-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"YaoBase.nucnorm","text":"nucnorm(m)\n\nComputes the nuclear norm of a matrix m.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.pure_state_fidelity-Tuple{Array{T,1} where T,Array{T,1} where T}","page":"Base","title":"YaoBase.pure_state_fidelity","text":"pure_state_fidelity(v1::Vector, v2::Vector)\n\nfidelity for pure states.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.purification_fidelity-Tuple{Array{T,2} where T,Array{T,2} where T}","page":"Base","title":"YaoBase.purification_fidelity","text":"purification_fidelity(m1::Matrix, m2::Matrix)\n\nFidelity for mixed states via purification.\n\nReference:     http://iopscience.iop.org/article/10.1088/1367-2630/aa6a4b/meta\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.rand_hermitian-Tuple{Int64}","page":"Base","title":"YaoBase.rand_hermitian","text":"rand_hermitian(N::Int) -> Matrix\n\nRandom hermitian matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.rand_unitary-Tuple{Int64}","page":"Base","title":"YaoBase.rand_unitary","text":"rand_unitary(N::Int) -> Matrix\n\nRandom unitary matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.rotmat-Tuple{AbstractArray{T,2} where T,Real}","page":"Base","title":"YaoBase.rotmat","text":"rotmat(M::AbstractMatrix, θ::Real)\n\nReturns rotated M: exp(-fracimθ2 M).\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.trnorm-Tuple{AbstractArray{T,2} where T}","page":"Base","title":"YaoBase.trnorm","text":"trnorm(m)\n\nComputes the trace norm of a matrix m.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#General-Properties-1","page":"Base","title":"General Properties","text":"","category":"section"},{"location":"man/base/#","page":"Base","title":"Base","text":"Modules = [YaoBase]\nPages = [\"inspect.jl\"]","category":"page"},{"location":"man/base/#LinearAlgebra.ishermitian-Tuple{Any}","page":"Base","title":"LinearAlgebra.ishermitian","text":"ishermitian(op) -> Bool\n\ncheck if this operator is hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.iscommute-Tuple","page":"Base","title":"YaoBase.iscommute","text":"iscommute(ops...) -> Bool\n\ncheck if operators are commute.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.isreflexive-Tuple{Any}","page":"Base","title":"YaoBase.isreflexive","text":"isreflexive(op) -> Bool\n\ncheck if this operator is reflexive.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.isunitary-Tuple{Any}","page":"Base","title":"YaoBase.isunitary","text":"isunitary(op) -> Bool\n\ncheck if this operator is a unitary operator.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#Error-and-Exceptions-1","page":"Base","title":"Error and Exceptions","text":"","category":"section"},{"location":"man/base/#","page":"Base","title":"Base","text":"Modules = [YaoBase]\nPages = [\"error.jl\"]","category":"page"},{"location":"man/base/#YaoBase.QubitMismatchError","page":"Base","title":"YaoBase.QubitMismatchError","text":"QubitMismatchError <: Exception\n\nQubit number mismatch error when applying a Block to a Register or concatenating Blocks.\n\n\n\n\n\n","category":"type"},{"location":"man/base/#YaoBase.islocs_conflict-Tuple{Union{Array{T,1}, Tuple{Vararg{T,N}} where N} where T}","page":"Base","title":"YaoBase.islocs_conflict","text":"islocs_conflict(locs) -> Bool\n\nCheck if the input locations has conflicts.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.islocs_inbounds-Tuple{Int64,Union{Array{T,1}, Tuple{Vararg{T,N}} where N} where T}","page":"Base","title":"YaoBase.islocs_inbounds","text":"islocs_inbounds(n, locs) -> Bool\n\nCheck if the input locations are inside given bounds n.\n\n\n\n\n\n","category":"method"},{"location":"man/base/#YaoBase.@assert_locs_inbounds-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Base","title":"YaoBase.@assert_locs_inbounds","text":"@assert_locs_inbounds <number of total qubits> <locations list> [<msg>]\n\nAssert if all the locations are inbounds.\n\n\n\n\n\n","category":"macro"},{"location":"man/base/#YaoBase.@assert_locs_safe-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Base","title":"YaoBase.@assert_locs_safe","text":"@assert_locs_safe <number of total qubits> <locations list> [<msg>]\n\nAssert if all the locations are:     - inbounds.     - do not have any conflict.\n\n\n\n\n\n","category":"macro"},{"location":"man/base/#Constants-1","page":"Base","title":"Constants","text":"","category":"section"},{"location":"man/base/#","page":"Base","title":"Base","text":"using Latexify, YaoBase\nconst_list = filter(x->x!==:Const, names(Const))\nname_list = map(string, const_list)\nmdtable(name_list; head=[\"defined constants\"])","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"DocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/registers/#abstract_registers-1","page":"Abstract Registers","title":"Abstract Registers","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"Quantum circuits process quantum states. A quantum state being processing by a quantum circuit will be stored on a quantum register. In Yao we provide several types for registers. The default type for registers is the ArrayReg which is defined in YaoArrayRegister.jl.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"The registers can be extended by subtyping AbstractRegister and define correspinding register interfaces defined in YaoBase.jl, which includes:","category":"page"},{"location":"man/registers/#Minimal-Required-Interfaces-1","page":"Abstract Registers","title":"Minimal Required Interfaces","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"The following interfaces are the minial required interfaces to make a register's printing work and be able to accept certain gates/blocks.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"But if you don't want to work with our default printing, you could define your custom printing with Base.show.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"YaoBase.nqubits\nYaoBase.nactive","category":"page"},{"location":"man/registers/#YaoBase.nqubits","page":"Abstract Registers","title":"YaoBase.nqubits","text":"nqubits(register) -> Int\n\nReturns the (total) number of qubits. See nactive, nremain for more details.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.nactive","page":"Abstract Registers","title":"YaoBase.nactive","text":"nactive(register) -> Int\n\nReturns the number of active qubits.\n\nnote: Note\nOperators always apply on active qubits.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"you can define instruct!, to provide specialized instructions for the registers from plain storage types.","category":"page"},{"location":"man/registers/#Qubit-Management-Interfaces-1","page":"Abstract Registers","title":"Qubit Management Interfaces","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"YaoBase.addbits!\nYaoBase.reorder!","category":"page"},{"location":"man/registers/#YaoBase.addbits!","page":"Abstract Registers","title":"YaoBase.addbits!","text":"addbits!(register, n::Int) -> register\naddbits!(n::Int) -> λ(register)\n\nAdd n qubits to given register in state |0>. i.e. |psi> -> |000> ⊗ |psi>, increased bits have higher indices.\n\nIf only an integer is provided, then returns a lambda function.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.reorder!","page":"Abstract Registers","title":"YaoBase.reorder!","text":"reorder!(reigster, orders)\n\nReorder the locations of register by input orders.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#Qubit-Scope-Management-Interfaces-1","page":"Abstract Registers","title":"Qubit Scope Management Interfaces","text":"","category":"section"},{"location":"man/registers/#LDT-format-1","page":"Abstract Registers","title":"LDT format","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"Concepturely, a wave function psirangle can be represented in a low dimentional tensor (LDT) format of order-3, L(f, r, b).","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"f: focused (i.e. operational) dimensions\nr: remaining dimensions\nb: batch dimension.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"For simplicity, let's ignore batch dimension for the now, we have","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"psirangle = sumlimits_xy L(x y ) jrangleirangle","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"Given a configuration x (in operational space), we want get the i-th bit using (x<<i) & 0x1, which means putting the small end the qubit with smaller index. In this representation L(x) will get return langle xpsirangle.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"note: Note\nWhy not the other convension: Using the convention of putting 1st bit on the big end will need to know the total number of qubits n in order to know such positional information.","category":"page"},{"location":"man/registers/#HDT-format-1","page":"Abstract Registers","title":"HDT format","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"Julia storage is column major, if we reshape the wave function to a shape of 2times2times  times2 and get the HDT (high dimensional tensor) format representation H, we can use H(x_1 x_2  x_3) to get langle xpsirangle.","category":"page"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"YaoBase.focus!\nYaoBase.relax!","category":"page"},{"location":"man/registers/#YaoBase.focus!","page":"Abstract Registers","title":"YaoBase.focus!","text":"focus!(register, locs) -> register\n\nFocus the wires on specified location.\n\nExample\n\njulia> focus!(r, (1, 2, 4))\n\n\n\n\n\n\nfocus!(locs...) -> f(register) -> register\n\nLazy version of focus!, this returns a lambda which requires a register.\n\n\n\n\n\nfocus(f, register, locs...)\n\nCall a callable f under the context of focus. See also focus!.\n\nExample\n\nprint the focused register\n\njulia> r = ArrayReg(bit\"101100\")\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 6/6\n\njulia> focus(x->(println(x);x), r, 1, 2);\nArrayReg{1,Complex{Float64},Array...}\n    active qubits: 2/6\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.relax!","page":"Abstract Registers","title":"YaoBase.relax!","text":"relax!(register[, locs]; to_nactive=nqubits(register)) -> register\n\nInverse transformation of focus!, where to_nactive is the number  of active bits for target register.\n\n\n\n\n\nrelax!(locs::Int...; to_nactive=nqubits(register)) -> f(register) -> register\n\nLazy version of relax!, it will be evaluated once you feed a register to its output lambda.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#Measurement-Interfaces-1","page":"Abstract Registers","title":"Measurement Interfaces","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"YaoBase.measure\nYaoBase.measure!\nYaoBase.measure_remove!\nYaoBase.measure_collapseto!\nYaoBase.select!","category":"page"},{"location":"man/registers/#YaoBase.measure","page":"Abstract Registers","title":"YaoBase.measure","text":"measure(register[, operator][, locs]; nshots=1) -> Vector{Int}\n\nReturn measurement results of current active qubits (regarding to active qubits, see focus! and relax!).\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.measure!","page":"Abstract Registers","title":"YaoBase.measure!","text":"measure!([operator, ]register[, locs])\n\nMeasure current active qubits or qubits at locs and collapse to result state.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.measure_remove!","page":"Abstract Registers","title":"YaoBase.measure_remove!","text":"measure_remove!([operator, ]reg::AbstractRegister[, locs])\n\nMeasure current active qubits or qubits at locs and remove them.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.measure_collapseto!","page":"Abstract Registers","title":"YaoBase.measure_collapseto!","text":"measure_collapseto!([operator, ]reg::AbstractRegister[, locs]; config) -> Int\n\nMeasure current active qubits or qubits at locs and set the register to specific value.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.select!","page":"Abstract Registers","title":"YaoBase.select!","text":"select!(dest::AbstractRegister, src::AbstractRegister, bits::Integer...) -> AbstractRegister\nselect!(register::AbstractRegister, bits::Integer...) -> register\n\nselect a subspace of given quantum state based on input eigen state bits. See also select.\n\nExample\n\nselect!(reg, 0b110) will select the subspace with (focused) configuration 110. After selection, the focused qubit space is 0, so you may want call relax! manually.\n\ntip: Tip\nDevelopers should overload select!(r::RegisterType, bits::NTuple{N, <:Integer}) and do not assume bits has specific number of bits (e.g Int64), or it will restrict the its maximum available number of qubits.\n\n\n\n\n\nselect!(b::Integer) -> f(register)\n\nLazy version of select!. See also select.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#Others-1","page":"Abstract Registers","title":"Others","text":"","category":"section"},{"location":"man/registers/#","page":"Abstract Registers","title":"Abstract Registers","text":"YaoBase.fidelity\nYaoBase.tracedist\nYaoBase.density_matrix\nYaoBase.viewbatch","category":"page"},{"location":"man/registers/#YaoBase.fidelity","page":"Abstract Registers","title":"YaoBase.fidelity","text":"fidelity(register1, register2)\n\nReturn the fidelity between two states.\n\nDefinition\n\nThe fidelity of two quantum state for qubits is defined as:\n\nF(ρ σ) = tr(sqrtsqrtρσsqrtρ)\n\nOr its equivalent form (which we use in numerical calculation):\n\nF(ρ σ) = sqrt(tr(ρσ) + 2 sqrtdet(ρ)det(σ))\n\nReference\n\nJozsa R. Fidelity for mixed quantum states[J]. Journal of modern optics, 1994, 41(12): 2315-2323.\nNielsen M A, Chuang I. Quantum computation and quantum information[J]. 2002.\n\nnote: Note\nThe original definition of fidelity F was from \"transition probability\", defined by Jozsa in 1994, it is the square of what we use here.\n\n\n\n\n\nfidelity(r1::ArrayReg, r2::ArrayReg)\n\nCalcuate the fidelity between r1 and r2, if r1 or r2 is not pure state (nactive(r) != nqubits(r)), the fidelity is calcuated by purification. See also pure_state_fidelity, purification_fidelity.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.tracedist","page":"Abstract Registers","title":"YaoBase.tracedist","text":"tracedist(register1, register2)\n\nReturn the trace distance of register1 and register2.\n\nDefinition\n\nTrace distance is defined as following:\n\nfrac12  A - B _tr\n\nReference\n\nhttps://en.wikipedia.org/wiki/Trace_distance\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.density_matrix","page":"Abstract Registers","title":"YaoBase.density_matrix","text":"density_matrix(register)\n\nReturns the density matrix of current active qubits.\n\n\n\n\n\n","category":"function"},{"location":"man/registers/#YaoBase.viewbatch","page":"Abstract Registers","title":"YaoBase.viewbatch","text":"viewbatch(register, i::Int) -> AbstractRegister{1}\n\nReturns a view of the i-th slice on batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#","page":"BitBasis","title":"BitBasis","text":"DocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/bitbasis/#BitBasis-1","page":"BitBasis","title":"BitBasis","text":"","category":"section"},{"location":"man/bitbasis/#","page":"BitBasis","title":"BitBasis","text":"Types and operations for basis represented by bits in linear algebra.","category":"page"},{"location":"man/bitbasis/#","page":"BitBasis","title":"BitBasis","text":"For more details please ref to BitBasis.jl.","category":"page"},{"location":"man/bitbasis/#","page":"BitBasis","title":"BitBasis","text":"Modules = [BitBasis]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/bitbasis/#BitBasis.@bit_str-Tuple{Any}","page":"BitBasis","title":"BitBasis.@bit_str","text":"@bit_str -> BitStr\n\nConstruct a bit string. such as bit\"0000\". The bit strings also supports string bcat. Just use it like normal strings.\n\nExample\n\njulia> bit\"10001\"\n10001 (17)\n\njulia> bit\"100_111_101\"\n100111101 (317)\n\njulia> bcat(bit\"1001\", bit\"11\", bit\"1110\")\n1001111110 (638)\n\njulia> v = collect(1:16);\n\njulia> v[bit\"1001\"]\n10\n\njulia> onehot(bit\"1001\")\n16-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 1.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n\n","category":"macro"},{"location":"man/bitbasis/#BitBasis.allone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T","page":"BitBasis","title":"BitBasis.allone","text":"allone(b::BitStr, mask::Integer) -> Bool\n\nReturn true if all masked position of index is 1.\n\nExample\n\ntrue if all masked positions are 1.\n\njulia> allone(bit\"1011\", 0b1011)\ntrue\n\njulia> allone(bit\"1011\", 0b1001)\ntrue\n\njulia> allone(bit\"1011\", 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"BitBasis","title":"BitBasis.allone","text":"allone(index::Integer, mask::Integer) -> Bool\n\nReturn true if all masked position of index is 1.\n\nExample\n\ntrue if all masked positions are 1.\n\njulia> allone(0b1011, 0b1011)\ntrue\n\njulia> allone(0b1011, 0b1001)\ntrue\n\njulia> allone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.anyone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T","page":"BitBasis","title":"BitBasis.anyone","text":"anyone(b::BitStr, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(bit\"1011\", 0b1001)\ntrue\n\njulia> anyone(bit\"1011\", 0b1100)\ntrue\n\njulia> anyone(bit\"1011\", 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"BitBasis","title":"BitBasis.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\n\njulia> anyone(0b1011, 0b1100)\ntrue\n\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.baddrs-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.baddrs","text":"baddrs(b::Integer) -> Vector\n\nget the locations of nonzeros bits, i.e. the inverse operation of bmask.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.baddrs-Tuple{Integer}","page":"BitBasis","title":"BitBasis.baddrs","text":"baddrs(b::Integer) -> Vector\n\nget the locations of nonzeros bits, i.e. the inverse operation of bmask.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.basis-Tuple{Union{Int64, AbstractArray}}","page":"BitBasis","title":"BitBasis.basis","text":"basis([IntType], nbits::Int) -> UnitRange{IntType}\nbasis([IntType], state::AbstractArray) -> UnitRange{IntType}\n\nReturns the UnitRange for basis in Hilbert Space of nbits qubits. If an array is supplied, it will return a basis having the same size with the first diemension of array.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bdistance-Union{Tuple{Ti}, Tuple{Ti,Ti}} where Ti<:Integer","page":"BitBasis","title":"BitBasis.bdistance","text":"bdistance(i::Integer, j::Integer) -> Int\n\nReturn number of different bits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bfloat-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.bfloat","text":"bfloat(b::BitStr) -> Float64\n\nfloat view, with MSB 0 bit numbering. See also wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bfloat-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bfloat","text":"bfloat(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with current bit numbering. See also bfloat_r.\n\nRef: wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bfloat_r-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.bfloat_r","text":"bfloat_r(b::Integer; nbits::Int) -> Float64\n\nfloat view, with bits read in inverse order.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bfloat_r-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bfloat_r","text":"bfloat_r(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with reversed bit numbering. See also bfloat.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bint-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.bint","text":"bint(b; nbits=nothing) -> Int\n\ninteger view, with LSB 0 bit numbering. See also wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bint-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bint","text":"bint(b; nbits=nothing) -> Int\n\ninteger view, with LSB 0 bit numbering. See also wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bint_r-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.bint_r","text":"bint_r(b; nbits::Int) -> Integer\n\ninteger read in inverse order.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bint_r-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bint_r","text":"bint_r(b; nbits::Int) -> Integer\n\ninteger read in inverse order.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bit-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bit","text":"bit(x[; len=ndigits(x, base=2)])\n\nCreate a BitStr accroding to integer x to given length len.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bit-Tuple{String}","page":"BitBasis","title":"BitBasis.bit","text":"bit(string)\n\nCreate a BitStr with given string of bits. See also @bit_str.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bit-Tuple{}","page":"BitBasis","title":"BitBasis.bit","text":"bit(;len)\n\nLazy curried version of bit.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bit_length-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bit_length","text":"bit_length(x::Integer) -> Int\n\nReturn the number of bits required to represent input integer x.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bit_literal-Tuple","page":"BitBasis","title":"BitBasis.bit_literal","text":"bit_literal(xs...)\n\nCreate a BitStr by input bits xs.\n\nExample\n\njulia> bit_literal(1, 0, 1, 0, 1, 1)\n110101 (53)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bitarray-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T<:Number","page":"BitBasis","title":"BitBasis.bitarray","text":"bitarray(v::Vector, [nbits::Int]) -> BitArray\nbitarray(v::Int, nbits::Int) -> BitArray\nbitarray(nbits::Int) -> Function\n\nConstruct BitArray from an integer vector, if nbits not supplied, it is 64. If an integer is supplied, it returns a function mapping a Vector/Int to bitarray.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bmask","page":"BitBasis","title":"BitBasis.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#BitBasis.breflect","page":"BitBasis","title":"BitBasis.breflect","text":"breflect(b::Integer[, masks::Vector{Integer}]; nbits) -> Integer\n\nReturn left-right reflected integer.\n\nExample\n\nReflect the order of bits.\n\njulia> breflect(0b1011; nbits=4) == 0b1101\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#BitBasis.breflect-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.breflect","text":"breflect(bit_str[, masks])\n\nReturn left-right reflected bit string.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.bsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"BitBasis","title":"BitBasis.bsizeof","text":"bsizeof(::Type)\n\nReturns the size of given type in number of binary digits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.btruncate-Tuple{Integer,Any}","page":"BitBasis","title":"BitBasis.btruncate","text":"truncate(b, n)\n\nTruncate bits b to given length n.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.controldo-Union{Tuple{S}, Tuple{N}, Tuple{Union{Function, Type},IterControl{N,S,T} where T}} where S where N","page":"BitBasis","title":"BitBasis.controldo","text":"controldo(f, itr::IterControl)\n\nExecute f while iterating itr.\n\nnote: Note\nthis is faster but equivalent than using itr as an iterator. See also itercontrol.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.controller-Tuple{Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14},Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14}}","page":"BitBasis","title":"BitBasis.controller","text":"controller(cbits, cvals) -> Function\n\nReturn a function that checks whether a basis at cbits takes specific value cvals.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.flip-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T","page":"BitBasis","title":"BitBasis.flip","text":"flip(bit_str, mask::Integer) -> Integer\n\nReturn an BitStr with bits at masked position flipped.\n\nExample\n\njulia> flip(bit\"1011\", 0b1011)\n0000 (0)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"BitBasis","title":"BitBasis.flip","text":"flip(index::Integer, mask::Integer) -> Integer\n\nReturn an Integer with bits at masked position flipped.\n\nExample\n\njulia> flip(0b1011, 0b1011) |> bit(len=4)\n0000 (0)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.group_shift!-Union{Tuple{N}, Tuple{Int64,AbstractArray{Int64,1}}} where N","page":"BitBasis","title":"BitBasis.group_shift!","text":"group_shift!(nbits, positions)\n\nShift bits on positions together.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.hypercubic-Tuple{Array}","page":"BitBasis","title":"BitBasis.hypercubic","text":"hypercubic(A::Array) -> Array\n\nget the hypercubic representation for an array.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.indices_with-Tuple{Int64,Array{Int64,1},Array{Int64,1}}","page":"BitBasis","title":"BitBasis.indices_with","text":"indices_with(n::Int, locs::Vector{Int}, vals::Vector{Int}) -> Vector{Int}\n\nReturn indices with specific positions locs with value vals in a hilbert space of n qubits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.invorder-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}","page":"BitBasis","title":"BitBasis.invorder","text":"invorder(X::AbstractVecOrMat)\n\nInverse the order of given vector/matrix X.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.ismatch-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer,Integer}} where T","page":"BitBasis","title":"BitBasis.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T<:Integer","page":"BitBasis","title":"BitBasis.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.itercontrol-Tuple{Int64,AbstractArray{T,1} where T,Any}","page":"BitBasis","title":"BitBasis.itercontrol","text":"itercontrol([T=Int], nbits, positions, bit_configs)\n\nReturns an iterator which iterate through controlled subspace of bits.\n\nExample\n\nTo iterate through all the bits satisfy 0xx10x1 where x means an arbitrary bit.\n\njulia> for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))\n           println(string(each, base=2, pad=7))\n       end\n0001001\n0001011\n0011001\n0011011\n0101001\n0101011\n0111001\n0111011\n\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.log2dim1-Tuple{Any}","page":"BitBasis","title":"BitBasis.log2dim1","text":"log2dim1(X)\n\nReturns the log2 of the first dimension's size.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.log2i","page":"BitBasis","title":"BitBasis.log2i","text":"log2i(x::Integer) -> Integer\n\nReturn log2(x), this integer version of log2 is fast but only valid for number equal to 2^n.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#BitBasis.neg-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.neg","text":"neg(bit_str) -> Integer\n\nReturn an BitStr with all bits flipped.\n\nExample\n\njulia> neg(bit\"1111\", 4)\n0000 (0)\n\njulia> neg(bit\"0111\", 4)\n1000 (8)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.neg-Union{Tuple{T}, Tuple{T,Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.neg","text":"neg(index::Integer, nbits::Int) -> Integer\n\nReturn an integer with all bits flipped (with total number of bit nbits).\n\nExample\n\njulia> neg(0b1111, 4) |> bit(len=4)\n0000 (0)\n\njulia> neg(0b0111, 4) |> bit(len=4)\n1000 (8)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},BitStr}} where T","page":"BitBasis","title":"BitBasis.onehot","text":"onehot([T=Float64], bit_str[, nbatch])\n\nReturns an onehot vector in type Vector{T}, or a batch of onehot vector in type Matrix{T}, where the bit_str-th element is one.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},Int64,Integer}} where T","page":"BitBasis","title":"BitBasis.onehot","text":"onehot([T=Float64], nbits, x::Integer[, nbatch::Int])\n\nCreate an onehot vector in type Vector{T} or a batch of onehot vector in type Matrix{T}, where index x + 1 is one.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.packbits-Tuple{AbstractArray{T,1} where T}","page":"BitBasis","title":"BitBasis.packbits","text":"packbits(arr::AbstractArray) -> AbstractArray\n\npack bits to integers, usually take a BitArray as input.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.readbit","text":"readbit(x, loc...)\n\nRead the bit config at given location.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.reorder","page":"BitBasis","title":"BitBasis.reorder","text":"reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\ntip: Tip\nAlthough orders can be any iterable, Tuple is preferred inorder to gain as much performance as possible. But the conversion won't take much anyway.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#BitBasis.setbit-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T","page":"BitBasis","title":"BitBasis.setbit","text":"setbit(b::BitStr, mask::Integer) -> Integer\n\nset the bit at masked position to 1.\n\nExample\n\njulia> setbit(bit\"1011\", 0b1100)\n1111 (15)\n\njulia> setbit(bit\"1011\", 0b0100)\n1111 (15)\n\njulia> setbit(bit\"1011\", 0b0000)\n1011 (11)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"BitBasis","title":"BitBasis.setbit","text":"setbit(index::Integer, mask::Integer) -> Integer\n\nset the bit at masked position to 1.\n\nExample\n\njulia> setbit(0b1011, 0b1100) |> bit(len=4)\n1111 (15)\n\njulia> setbit(0b1011, 0b0100) |> bit(len=4)\n1111 (15)\n\njulia> setbit(0b1011, 0b0000) |> bit(len=4)\n1011 (11)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.swapbits-Tuple{BitStr,Int64,Int64}","page":"BitBasis","title":"BitBasis.swapbits","text":"swapbits(n::BitStr, mask_ij::Integer) -> BitStr\nswapbits(n::BitStr, i::Int, j::Int) -> BitStr\n\nReturn a BitStr with bits at i and j flipped.\n\nExample\n\njulia> swapbits(0b1011, 0b1100) == 0b0111\ntrue\n\nwarning: Warning\nmask_ij should only contain two 1, swapbits will not check it, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.swapbits","text":"swapbits(n::Integer, mask_ij::Integer) -> Integer\nswapbits(n::Integer, i::Int, j::Int) -> Integer\n\nReturn an integer with bits at i and j flipped.\n\nExample\n\njulia> swapbits(0b1011, 0b1100) == 0b0111\ntrue\n\ntip: Tip\nlocations i and j specified by mask could be faster when bmask is not straight forward but known by constant.\n\nwarning: Warning\nmask_ij should only contain two 1, swapbits will not check it, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.to_location-Tuple{Any}","page":"BitBasis","title":"BitBasis.to_location","text":"to_location(x)\n\nConvert bit configuration x to an index.\n\nExample\n\njulia> to_location(1)\n2\n\njulia> to_location(bit\"111\")\n111 (7)\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.BitStr","page":"BitBasis","title":"BitBasis.BitStr","text":"BitStr{T}\n\nString literal for bits.\n\nBitStr(value[, len=ndigits(value)])\n\nReturns a BitStr, by default the length is set to the minimum length required to represent value as bits.\n\nBitStr(str::String)\n\nParse the input string to a BitStr. See @bit_str for more details.\n\nExample\n\nBitStr supports some basic arithmetic operations. It acts like an integer, but supports some frequently used methods for binary basis.\n\njulia> bit\"101\" * 2\n1010 (10)\n\njulia> bcat(bit\"101\" for i in 1:10)\n101101101101101101101101101101 (766958445)\n\njulia> repeat(bit\"101\", 2)\n101101 (45)\n\njulia> bit\"1101\"[2]\n0\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis/#BitBasis.IterControl","page":"BitBasis","title":"BitBasis.IterControl","text":"IterControl{N, S, T}\n\nIterator to iterate through controlled subspace. See also itercontrol. N is the size of whole hilbert space, S is the number of shifts.\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis/#BitBasis.ReorderedBasis","page":"BitBasis","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis{N, T}\n\nLazy reorderd basis.\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis/#BitBasis.ReorderedBasis-Union{Tuple{Tuple{Vararg{T,N}}}, Tuple{T}, Tuple{N}} where T<:Integer where N","page":"BitBasis","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis(orders::NTuple{N, <:Integer})\n\nReturns a lazy set of reordered basis.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.next_reordered_basis-Union{Tuple{T}, Tuple{N}, Tuple{T,Tuple{Vararg{T,N}},Tuple{Vararg{T,N}}}} where T where N","page":"BitBasis","title":"BitBasis.next_reordered_basis","text":"next_reordered_basis(basis, takers, differ)\n\nReturns the next reordered basis accroding to current basis.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.unsafe_reorder","page":"BitBasis","title":"BitBasis.unsafe_reorder","text":"unsafe_reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\nwarning: Warning\nunsafe_reorder won't check whether the length of orders and the size of first dimension of X match, use at your own risk.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis/#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{N}, Tuple{UnitRange{T},Tuple{Vararg{T,N}}}} where T where N","page":"BitBasis","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange, b::NTuple{N}) -> NTuple{N}\n\nReturns result in type Tuple of a .- b. This will not check the length of a and b, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis/#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{UnitRange{T},Array{T,1}}} where T","page":"BitBasis","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange{T}, b::Vector{T}) where T\n\nReturns a .- b, fallback version when b is a Vector.\n\n\n\n\n\n","category":"method"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"DocTestSetup = quote\n    using Yao, YaoBase, YaoBlocks, YaoArrayRegister\nend","category":"page"},{"location":"man/extending_blocks/#Extending-Blocks-1","page":"Extending Blocks","title":"Extending Blocks","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Blocks are defined as a sub-type system inside Julia, you could extend it by defining new Julia types by subtyping abstract types we provide. But we also provide some handy tools to help you create your own blocks.","category":"page"},{"location":"man/extending_blocks/#Define-Custom-Constant-Blocks-1","page":"Extending Blocks","title":"Define Custom Constant Blocks","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Constant blocks are used quite often and in numerical simulation we would expect it to be a real constant in the program, which means it won't allocate new memory when we try to get its matrix for several times, and it won't change with parameters.","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"In Yao, you can simply define a constant block with @const_gate, with the corresponding matrix:","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"using YaoBlocks, BitBasis # hide\n@const_gate Rand = rand(ComplexF64, 4, 4)","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"This will automatically create a type RandGate{T} and a constant binding Rand to the instance of RandGate{ComplexF64}, and it will also bind a Julia constant for the given matrix, so when you call mat(Rand), no allocation will happen.","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"@allocated mat(Rand)","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"If you want to use other data type like ComplexF32, you could directly call Rand(ComplexF32), which will create a new instance with data type ComplexF32.","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Rand(ComplexF32)","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"But remember this won't bind the matrix, it only binds the matrix you give","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"@allocated mat(Rand(ComplexF32))","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"so if you want to make the matrix call mat for ComplexF32 to have zero allocation as well, you need to do it explicitly.","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"@const_gate Rand::ComplexF32","category":"page"},{"location":"man/extending_blocks/#Define-Custom-Blocks-1","page":"Extending Blocks","title":"Define Custom Blocks","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Primitive blocks are the most basic block to build a quantum circuit, if a primitive block has a certain structure, like containing tweakable parameters, it cannot be defined as a constant, thus create a new type by subtyping PrimitiveBlock is necessary","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"using YaoBlocks\n\nmutable struct PhaseGate{T <: Real} <: PrimitiveBlock{1}\n    theta::T\nend","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"If your insterested block is a composition of other blocks, you should define a CompositeBlock, e.g","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"struct ChainBlock{N} <: CompositeBlock{N}\n    blocks::Vector{AbstractBlock{N}}\nend","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Besides types, there are several interfaces you could define for a block, but don't worry, they should just error if it doesn't work.","category":"page"},{"location":"man/extending_blocks/#Define-the-matrix-1","page":"Extending Blocks","title":"Define the matrix","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"The matrix form of a block is the minimal requirement to make a custom block functional, defining it is super simple, e.g for phase gate:","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"mat(::Type{T}, gate::PhaseGate) where T = exp(T(im * gate.theta)) * Matrix{Complex{T}}(I, 2, 2)","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Or for composite blocks, you could just calculate the matrix by call mat on its subblocks.","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"mat(::Type{T}, c::ChainBlock) where T = prod(x->mat(T, x), reverse(c.blocks))","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"The rest will just work, but might be slow since you didn't define any specification for this certain block.","category":"page"},{"location":"man/extending_blocks/#Define-how-blocks-are-applied-to-registers-1","page":"Extending Blocks","title":"Define how blocks are applied to registers","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Although, having its matrix is already enough for applying a block to register, we could improve the performance or dispatch to other actions by overloading apply! interface, e.g we can use specialized instruction to make X gate (a builtin gate defined @const_gate) faster:","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"function apply!(r::ArrayReg, x::XGate)\n    nactive(r) == 1 || throw(QubitMismatchError(\"register size $(nactive(r)) mismatch with block size $N\"))\n    instruct!(matvec(r.state), Val(:X), (1, ))\n    return r\nend","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"In Yao, this interface allows us to provide more aggressive specialization on different patterns of quantum circuits to accelerate the simulation etc.","category":"page"},{"location":"man/extending_blocks/#Define-Parameters-1","page":"Extending Blocks","title":"Define Parameters","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"If you want to use some member of the block to be parameters, you need to declare them explicitly","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"niparams(::Type{<:PhaseGate}) = 1\ngetiparams(x::PhaseGate) = x.theta\nsetiparams!(r::PhaseGate, param::Real) = (r.theta = param; r)","category":"page"},{"location":"man/extending_blocks/#Define-Adjoint-1","page":"Extending Blocks","title":"Define Adjoint","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Since blocks are actually quantum operators, it makes sense to call their adjoint as well. We provide Daggered for general purpose, but some blocks may have more specific transformation rules for adjoints, e.g","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"Base.adjoint(x::PhaseGate) = PhaseGate(-x.theta)","category":"page"},{"location":"man/extending_blocks/#Define-Cache-Keys-1","page":"Extending Blocks","title":"Define Cache Keys","text":"","category":"section"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"To enable cache, you should define cache_key, e.g for phase gate, we only cares about its phase, instead of the whole instance","category":"page"},{"location":"man/extending_blocks/#","page":"Extending Blocks","title":"Extending Blocks","text":"cache_key(gate::PhaseGate) = gate.theta","category":"page"}]
}
