<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Blocks · Yao.jl</title><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/man/extending_blocks/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.svg" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../examples/QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../../examples/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../array_registers/">Array Registers</a></li><li><a class="toctext" href="../blocks/">Blocks</a></li><li><a class="toctext" href="../base/">Base</a></li><li><a class="toctext" href="../registers/">Abstract Registers</a></li><li><a class="toctext" href="../bitbasis/">BitBasis</a></li><li class="current"><a class="toctext" href>Extending Blocks</a><ul class="internal"><li><a class="toctext" href="#Define-Custom-Constant-Blocks-1">Define Custom Constant Blocks</a></li><li><a class="toctext" href="#Define-Custom-Blocks-1">Define Custom Blocks</a></li><li><a class="toctext" href="#Define-the-matrix-1">Define the matrix</a></li><li><a class="toctext" href="#Define-how-blocks-are-applied-to-registers-1">Define how blocks are applied to registers</a></li><li><a class="toctext" href="#Define-Parameters-1">Define Parameters</a></li><li><a class="toctext" href="#Define-Adjoint-1">Define Adjoint</a></li><li><a class="toctext" href="#Define-Cache-Keys-1">Define Cache Keys</a></li></ul></li><li><a class="toctext" href="../benchmarks/">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Extending Blocks</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/extending_blocks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending Blocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Extending-Blocks-1" href="#Extending-Blocks-1">Extending Blocks</a></h1><p>Blocks are defined as a sub-type system inside Julia, you could extend it by defining new Julia types by subtyping abstract types we provide. But we also provide some handy tools to help you create your own blocks.</p><h2><a class="nav-anchor" id="Define-Custom-Constant-Blocks-1" href="#Define-Custom-Constant-Blocks-1">Define Custom Constant Blocks</a></h2><p>Constant blocks are used quite often and in numerical simulation we would expect it to be a real constant in the program, which means it won&#39;t allocate new memory when we try to get its matrix for several times, and it won&#39;t change with parameters.</p><p>In Yao, you can simply define a constant block with <a href="man/@ref"><code>@const_gate</code></a>, with the corresponding matrix:</p><pre><code class="language-julia-repl">
julia&gt; @const_gate Rand = rand(ComplexF64, 4, 4)</code></pre><p>This will automatically create a type <code>RandGate{T}</code> and a constant binding <code>Rand</code> to the instance of <code>RandGate{ComplexF64}</code>, and it will also bind a Julia constant for the given matrix, so when you call <code>mat(Rand)</code>, no allocation will happen.</p><pre><code class="language-julia-repl">julia&gt; @allocated mat(Rand)
ERROR: UndefVarError: mat not defined</code></pre><p>If you want to use other data type like <code>ComplexF32</code>, you could directly call <code>Rand(ComplexF32)</code>, which will create a new instance with data type <code>ComplexF32</code>.</p><pre><code class="language-julia-repl">julia&gt; Rand(ComplexF32)
ERROR: UndefVarError: Rand not defined</code></pre><p>But remember this won&#39;t bind the matrix, it only binds <strong>the matrix you give</strong></p><pre><code class="language-julia-repl">julia&gt; @allocated mat(Rand(ComplexF32))
ERROR: UndefVarError: Rand not defined</code></pre><p>so if you want to make the matrix call <code>mat</code> for <code>ComplexF32</code> to have zero allocation as well, you need to do it explicitly.</p><pre><code class="language-julia-repl">julia&gt; @const_gate Rand::ComplexF32
ERROR: LoadError: UndefVarError: @const_gate not defined
in expression starting at none:1</code></pre><h2><a class="nav-anchor" id="Define-Custom-Blocks-1" href="#Define-Custom-Blocks-1">Define Custom Blocks</a></h2><p>Primitive blocks are the most basic block to build a quantum circuit, if a primitive block has a certain structure, like containing tweakable parameters, it cannot be defined as a constant, thus create a new type by subtyping <a href="../blocks/#YaoBlocks.PrimitiveBlock"><code>PrimitiveBlock</code></a> is necessary</p><pre><code class="language-julia">using YaoBlocks

mutable struct PhaseGate{T &lt;: Real} &lt;: PrimitiveBlock{1}
    theta::T
end</code></pre><p>If your insterested block is a composition of other blocks, you should define a <a href="../blocks/#YaoBlocks.CompositeBlock"><code>CompositeBlock</code></a>, e.g</p><pre><code class="language-julia">struct ChainBlock{N} &lt;: CompositeBlock{N}
    blocks::Vector{AbstractBlock{N}}
end</code></pre><p>Besides types, there are several interfaces you could define for a block, but don&#39;t worry, they should just error if it doesn&#39;t work.</p><h2><a class="nav-anchor" id="Define-the-matrix-1" href="#Define-the-matrix-1">Define the matrix</a></h2><p>The matrix form of a block is the minimal requirement to make a custom block functional, defining it is super simple, e.g for phase gate:</p><pre><code class="language-julia">mat(::Type{T}, gate::PhaseGate) where T = exp(T(im * gate.theta)) * Matrix{Complex{T}}(I, 2, 2)</code></pre><p>Or for composite blocks, you could just calculate the matrix by call <code>mat</code> on its subblocks.</p><pre><code class="language-julia">mat(::Type{T}, c::ChainBlock) where T = prod(x-&gt;mat(T, x), reverse(c.blocks))</code></pre><p>The rest will just work, but might be slow since you didn&#39;t define any specification for this certain block.</p><h2><a class="nav-anchor" id="Define-how-blocks-are-applied-to-registers-1" href="#Define-how-blocks-are-applied-to-registers-1">Define how blocks are applied to registers</a></h2><p>Although, having its matrix is already enough for applying a block to register, we could improve the performance or dispatch to other actions by overloading <a href="../blocks/#YaoBlocks.apply!-Tuple{AbstractRegister,AbstractBlock}"><code>apply!</code></a> interface, e.g we can use specialized instruction to make X gate (a builtin gate defined <code>@const_gate</code>) faster:</p><pre><code class="language-julia">function apply!(r::ArrayReg, x::XGate)
    nactive(r) == 1 || throw(QubitMismatchError(&quot;register size $(nactive(r)) mismatch with block size $N&quot;))
    instruct!(matvec(r.state), Val(:X), (1, ))
    return r
end</code></pre><p>In Yao, this interface allows us to provide more aggressive specialization on different patterns of quantum circuits to accelerate the simulation etc.</p><h2><a class="nav-anchor" id="Define-Parameters-1" href="#Define-Parameters-1">Define Parameters</a></h2><p>If you want to use some member of the block to be parameters, you need to declare them explicitly</p><pre><code class="language-julia">niparams(::Type{&lt;:PhaseGate}) = 1
getiparams(x::PhaseGate) = x.theta
setiparams!(r::PhaseGate, param::Real) = (r.theta = param; r)</code></pre><h2><a class="nav-anchor" id="Define-Adjoint-1" href="#Define-Adjoint-1">Define Adjoint</a></h2><p>Since blocks are actually quantum operators, it makes sense to call their <code>adjoint</code> as well. We provide <a href="../blocks/#YaoBlocks.Daggered"><code>Daggered</code></a> for general purpose, but some blocks may have more specific transformation rules for adjoints, e.g</p><pre><code class="language-julia">Base.adjoint(x::PhaseGate) = PhaseGate(-x.theta)</code></pre><h2><a class="nav-anchor" id="Define-Cache-Keys-1" href="#Define-Cache-Keys-1">Define Cache Keys</a></h2><p>To enable cache, you should define <code>cache_key</code>, e.g for phase gate, we only cares about its phase, instead of the whole instance</p><pre><code class="language-julia">cache_key(gate::PhaseGate) = gate.theta</code></pre><footer><hr/><a class="previous" href="../bitbasis/"><span class="direction">Previous</span><span class="title">BitBasis</span></a><a class="next" href="../benchmarks/"><span class="direction">Next</span><span class="title">Benchmarks</span></a></footer></article></body></html>
