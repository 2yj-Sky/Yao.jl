<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit · Yao.jl</title><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/examples/GHZ/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.svg" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href>Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a><ul class="internal"><li><a class="toctext" href="#Put-single-qubit-gate-X-to-location-1-1">Put single qubit gate X to location 1</a></li><li><a class="toctext" href="#Apply-the-same-gate-on-different-locations-1">Apply the same gate on different locations</a></li><li><a class="toctext" href="#Define-control-gates-1">Define control gates</a></li><li><a class="toctext" href="#Composite-each-part-together-1">Composite each part together</a></li><li><a class="toctext" href="#Construct-GHZ-state-from-00...00-1">Construct GHZ state from 00...00</a></li><li><a class="toctext" href="#Feed-Registers-to-Circuits-1">Feed Registers to Circuits</a></li></ul></li><li><a class="toctext" href="../QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/array_registers/">Array Registers</a></li><li><a class="toctext" href="../../man/blocks/">Blocks</a></li><li><a class="toctext" href="../../man/base/">Base</a></li><li><a class="toctext" href="../../man/registers/">Abstract Registers</a></li><li><a class="toctext" href="../../man/bitbasis/">BitBasis</a></li><li><a class="toctext" href="../../man/extending_blocks/">Extending Blocks</a></li><li><a class="toctext" href="../../man/benchmarks/">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/examples/GHZ.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="example-ghz-1" href="#example-ghz-1">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></h1><p>First, you have to use this package in Julia.</p><pre><code class="language-julia">using Yao</code></pre><p>Now, we just define the circuit according to the circuit image below:</p><p><img src="../../assets/figures/ghz4.png" alt="ghz"/></p><pre><code class="language-julia">circuit = chain(
    4,
    put(1=&gt;X),
    repeat(H, 2:4),
    control(2, 1=&gt;X),
    control(4, 3=&gt;X),
    control(3, 1=&gt;X),
    control(4, 3=&gt;X),
    repeat(H, 1:4),
)</code></pre><pre><code class="language-none">nqubits: 4
chain
├─ put on (1)
│  └─ X gate
├─ repeat on (2, 3, 4)
│  └─ H gate
├─ control(2)
│  └─ (1,) X gate
├─ control(4)
│  └─ (3,) X gate
├─ control(3)
│  └─ (1,) X gate
├─ control(4)
│  └─ (3,) X gate
└─ repeat on (1, 2, 3, 4)
   └─ H gate</code></pre><p>Let me explain what happens here.</p><h2><a class="nav-anchor" id="Put-single-qubit-gate-X-to-location-1-1" href="#Put-single-qubit-gate-X-to-location-1-1">Put single qubit gate X to location 1</a></h2><p>we have an <a href="examples/@ref"><code>X</code></a> gate applied to the first qubit.</p><p>We need to tell <code>Yao</code> to put this gate on the first qubit by</p><pre><code class="language-julia">put(4, 1=&gt;X)</code></pre><pre><code class="language-none">nqubits: 4
put on (1)
└─ X gate</code></pre><p>We use Julia&#39;s <code>Pair</code> to denote the gate and its location in the circuit, for two-qubit gate, you could also use a tuple of locations:</p><pre><code class="language-julia">put(4, (1, 2)=&gt;swap(2, 1, 2))</code></pre><pre><code class="language-none">nqubits: 4
put on (1, 2)
└─ put on (1, 2)
   └─ SWAP gate</code></pre><p>But, wait, why there&#39;s no <code>4</code> in the definition above? This is because all the functions in <code>Yao</code> that requires to input the number of qubits as its first arguement could be lazy (curried), and let other constructors to infer the total number of qubits later, e.g</p><pre><code class="language-julia">put(1=&gt;X)</code></pre><pre><code class="language-none">(n -&gt; put(n, 1 =&gt; X gate))</code></pre><p>which will return a lambda that ask for a single arguement <code>n</code>.</p><pre><code class="language-julia">put(1=&gt;X)(4)</code></pre><pre><code class="language-none">nqubits: 4
put on (1)
└─ X gate</code></pre><h2><a class="nav-anchor" id="Apply-the-same-gate-on-different-locations-1" href="#Apply-the-same-gate-on-different-locations-1">Apply the same gate on different locations</a></h2><p>next we should put Hadmard gates on all locations except the 1st qubits.</p><p>We provide <a href="../../man/array_registers/#Base.repeat"><code>repeat</code></a> to apply the same block repeatly, repeat can take an iterator of desired locations, and like <code>put</code>, we can also leave the total number of qubits there.</p><pre><code class="language-julia">repeat(H, 2:4)</code></pre><pre><code class="language-none">(n -&gt; repeat(n, H gate, 2, 3, 4))</code></pre><h2><a class="nav-anchor" id="Define-control-gates-1" href="#Define-control-gates-1">Define control gates</a></h2><p>In Yao, we could define controlled gates by feeding a gate to <a href="../../man/blocks/#YaoBlocks.control-Tuple{Any,Pair}"><code>control</code></a></p><pre><code class="language-julia">control(4, 2, 1=&gt;X)</code></pre><pre><code class="language-none">nqubits: 4
control(2)
└─ (1,) X gate</code></pre><p>Like many others, you could leave the number of total qubits there, and infer it later.</p><pre><code class="language-julia">control(2, 1=&gt;X)</code></pre><pre><code class="language-none">(n -&gt; control(n, 2, 1 =&gt; X gate))</code></pre><h2><a class="nav-anchor" id="Composite-each-part-together-1" href="#Composite-each-part-together-1">Composite each part together</a></h2><p>This will create a <a href="examples/@ref"><code>ControlBlock</code></a>, the concept of block in Yao basically just means quantum operators, since the quantum circuit itself is a quantum operator, we could create a quantum circuit by composite each part of.</p><p>Here, we use <a href="../../man/blocks/#YaoBlocks.chain-Tuple{Int64}"><code>chain</code></a> to chain each part together, a chain of quantum operators means to apply each operators one by one in the chain. This will create a <a href="../../man/blocks/#YaoBlocks.ChainBlock"><code>ChainBlock</code></a>.</p><pre><code class="language-julia">circuit = chain(
    4,
    put(1=&gt;X),
    repeat(H, 2:4),
    control(2, 1=&gt;X),
    control(4, 3=&gt;X),
    control(3, 1=&gt;X),
    control(4, 3=&gt;X),
    repeat(H, 1:4),
)</code></pre><pre><code class="language-none">nqubits: 4
chain
├─ put on (1)
│  └─ X gate
├─ repeat on (2, 3, 4)
│  └─ H gate
├─ control(2)
│  └─ (1,) X gate
├─ control(4)
│  └─ (3,) X gate
├─ control(3)
│  └─ (1,) X gate
├─ control(4)
│  └─ (3,) X gate
└─ repeat on (1, 2, 3, 4)
   └─ H gate</code></pre><p>You can check the type of it with <code>typeof</code></p><pre><code class="language-julia">typeof(circuit)</code></pre><pre><code class="language-none">ChainBlock{4}</code></pre><h2><a class="nav-anchor" id="Construct-GHZ-state-from-00...00-1" href="#Construct-GHZ-state-from-00...00-1">Construct GHZ state from 00...00</a></h2><p>For simulation, we provide a builtin register type called <a href="../../man/array_registers/#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a>, we will use the simulated register in this example.</p><p>First, let&#39;s create <span>$|00⋯00⟩$</span>, you can create it with <a href="../../man/array_registers/#YaoArrayRegister.zero_state"><code>zero_state</code></a></p><pre><code class="language-julia">zero_state(4)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 4/4</code></pre><p>Or we also provide bit string literals to create arbitrary eigen state</p><pre><code class="language-julia">ArrayReg(bit&quot;0000&quot;)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 4/4</code></pre><p>They will both create a register with Julia&#39;s builtin <code>Array</code> as storage.</p><h2><a class="nav-anchor" id="Feed-Registers-to-Circuits-1" href="#Feed-Registers-to-Circuits-1">Feed Registers to Circuits</a></h2><p>Circuits can be applied to registers with <a href="examples/@ref"><code>apply!</code></a></p><pre><code class="language-julia">apply!(zero_state(4), circuit)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 4/4</code></pre><p>or you can use pipe operator <code>|&gt;</code>, when you want to chain several operations together, here we measure the state right after the circuit for <code>1000</code> times</p><pre><code class="language-julia">results = zero_state(4) |&gt; circuit |&gt; r-&gt;measure(r, nshots=1000)</code></pre><pre><code class="language-none">1000-element Array{BitStr{4,Int64},1}:
 1111 ₍₂₎
 1111 ₍₂₎
 0000 ₍₂₎
 1111 ₍₂₎
 1111 ₍₂₎
 1111 ₍₂₎
 1111 ₍₂₎
 0000 ₍₂₎
 0000 ₍₂₎
 0000 ₍₂₎
        ⋮
 0000 ₍₂₎
 0000 ₍₂₎
 0000 ₍₂₎
 1111 ₍₂₎
 0000 ₍₂₎
 1111 ₍₂₎
 0000 ₍₂₎
 0000 ₍₂₎
 1111 ₍₂₎</code></pre><p><img src="../../assets/figures/GHZ.png" alt="GHZ"/></p><p>GHZ state will collapse to <span>$|0000⟩$</span> or <span>$|1111⟩$</span>.</p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../QFT/"><span class="direction">Next</span><span class="title">Quantum Fourier Transformation and Phase Estimation</span></a></footer></article></body></html>
