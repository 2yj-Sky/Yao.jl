<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Registers · Yao</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/man/registers/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Yao</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transform</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../yao/">Yao</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li class="current"><a class="toctext" href>Registers</a><ul class="internal"><li><a class="toctext" href="#Storage-1">Storage</a></li><li><a class="toctext" href="#Operations-1">Operations</a></li><li><a class="toctext" href="#Registers-2">Registers</a></li></ul></li><li><a class="toctext" href="../blocks/">Blocks System</a></li><li><a class="toctext" href="../cache/">Cache System</a></li><li><a class="toctext" href="../intrinsics/">Intrinsics</a></li><li><a class="toctext" href="../luxurysparse/">LuxurySparse</a></li><li><a class="toctext" href="../boost/">Boost</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../dev/extending-blocks/">Extending Blocks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Registers</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/registers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Registers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Registers-1" href="#Registers-1">Registers</a></h1><p>Quantum circuits process quantum states. A quantum state being processing by a quantum circuit will be stored on a quantum register. In <strong>Yao</strong> we provide several types for registers. The default type for registers is the <a href="#Yao.Registers.DefaultRegister"><code>Yao.Registers.DefaultRegister</code></a>.</p><p>You can directly use factory method <a href="#Yao.Registers.register"><code>register</code></a></p><h2><a class="nav-anchor" id="Storage-1" href="#Storage-1">Storage</a></h2><h4><a class="nav-anchor" id="LDT-format-1" href="#LDT-format-1">LDT format</a></h4><p>Concepturely, a wave function <span>$|\psi\rangle$</span> can be represented in a low dimentional tensor (LDT) format of order-3, L(f, r, b).</p><ul><li><p>f: focused (i.e. operational) dimensions</p></li><li><p>r: remaining dimensions</p></li><li><p>b: batch dimension.</p></li></ul><p>For simplicity, let&#39;s ignore batch dimension for the momentum, we have</p><div>\[|\psi\rangle = \sum\limits_{x,y} L(x, y, .) |j\rangle|i\rangle\]</div><p>Given a configuration <code>x</code> (in operational space), we want get the i-th bit using <code>(x&lt;&lt;i) &amp; 0x1</code>, which means putting the small end the qubit with smaller index. In this representation <code>L(x)</code> will get return <span>$\langle x|\psi\rangle$</span>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Why not the other convension</strong>: Using the convention of putting 1st bit on the big end will need to know the total number of qubits <code>n</code> in order to know such positional information.</p></div></div><h4><a class="nav-anchor" id="HDT-format-1" href="#HDT-format-1">HDT format</a></h4><p>Julia storage is column major, if we reshape the wave function to a shape of <span>$2\times2\times ... \times2$</span> and get the HDT (high dimensional tensor) format representation H, we can use H(<span>$x_1, x_2, ..., x_3$</span>) to get <span>$\langle x|\psi\rangle$</span>.</p><h2><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h2><h4><a class="nav-anchor" id="Kronecker-product-of-operators-1" href="#Kronecker-product-of-operators-1">Kronecker product of operators</a></h4><p>In order to put small bits on little end, the Kronecker product is <span>$O = o_n \otimes \ldots \otimes o_2 \otimes o_1$</span> where the subscripts are qubit indices.</p><h4><a class="nav-anchor" id="Measurements-1" href="#Measurements-1">Measurements</a></h4><p>Measure means <code>sample</code> and <code>projection</code>.</p><h5><a class="nav-anchor" id="Sample-1" href="#Sample-1">Sample</a></h5><p>Suppose we want to measure operational subspace, we can first get</p><div>\[p(x) = \|\langle x|\psi\rangle\|^2 = \sum\limits_{y} \|L(x, y, .)\|^2.\]</div><p>Then we sample an <span>$a\sim p(x)$</span>. If we just sample and don&#39;t really measure (change wave function), its over.</p><h5><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h5><div>\[|\psi\rangle&#39; = \sum_y L(a, y, .)/\sqrt{p(a)} |a\rangle |y\rangle\]</div><p>Good! then we can just remove the operational qubit space since <code>x</code> and <code>y</code> spaces are totally decoupled and <code>x</code> is known as in state <code>a</code>, then we get</p><div>\[|\psi\rangle&#39;_r = \sum_y l(0, y, .) |y\rangle\]</div><p>where <code>l = L(a:a, :, :)/sqrt(p(a))</code>.</p><h2><a class="nav-anchor" id="Registers-2" href="#Registers-2">Registers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.AbstractRegister" href="#Yao.Registers.AbstractRegister"><code>Yao.Registers.AbstractRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractRegister{B, T}</code></pre><p>abstract type that registers will subtype from. <code>B</code> is the batch size, <code>T</code> is the data type.</p><p><strong>Required Properties</strong></p><table><tr><th>Property</th><th>Description</th><th>default</th></tr><tr><td><code>nqubits(reg)</code></td><td>get the total number of qubits.</td><td></td></tr><tr><td><code>nactive(reg)</code></td><td>get the number of active qubits.</td><td></td></tr><tr><td><code>nremain(reg)</code></td><td>get the number of remained qubits.</td><td>nqubits - nactive</td></tr><tr><td><code>nbatch(reg)</code></td><td>get the number of batch.</td><td><code>B</code></td></tr><tr><td><code>state(reg)</code></td><td>get the state of this register. It always return the matrix stored inside.</td><td></td></tr><tr><td><code>statevec(reg)</code></td><td>get the raveled state of this register.                                  .</td><td></td></tr><tr><td><code>hypercubic(reg)</code></td><td>get the hypercubic form of this register.                                  .</td><td></td></tr><tr><td><code>eltype(reg)</code></td><td>get the element type stored by this register on classical memory. (the type Julia should use to represent amplitude)</td><td><code>T</code></td></tr><tr><td><code>copy(reg)</code></td><td>copy this register.</td><td></td></tr><tr><td><code>similar(reg)</code></td><td>construct a new register with similar configuration.</td><td></td></tr></table><p><strong>Required Methods</strong></p><p><strong>Multiply</strong></p><pre><code class="language-none">*(op, reg)</code></pre><p>define how operator <code>op</code> act on this register. This is quite useful when there is a special approach to apply an operator on this register. (e.g a register with no batch, or a register with a MPS state, etc.)</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>be careful, generally, operators can only be applied to a register, thus we should only overload this operation and do not overload <code>*(reg, op)</code>.</p></div></div><p><strong>Pack Address</strong></p><p>pack <code>addrs</code> together to the first k-dimensions.</p><p><strong>Example</strong></p><p>Given a register with dimension <code>[2, 3, 1, 5, 4]</code>, we pack <code>[5, 4]</code> to the first 2 dimensions. We will get <code>[5, 4, 2, 3, 1]</code>.</p><p><strong>Focus Address</strong></p><pre><code class="language-none">focus!(reg, range)</code></pre><p>merge address in <code>range</code> together as one dimension (the active space).</p><p><strong>Example</strong></p><p>Given a register with dimension <code>(2^4)x3</code> and address [1, 2, 3, 4], we focus address <code>[3, 4]</code>, will pack <code>[3, 4]</code> together and merge them as the active space. Then we will have a register with size <code>2^2x(2^2x3)</code>, and address <code>[3, 4, 1, 2]</code>.</p><p><strong>Initializers</strong></p><p>Initializers are functions that provide specific quantum states, e.g zero states, random states, GHZ states and etc.</p><pre><code class="language-none">register(::Type{RT}, raw, nbatch)</code></pre><p>an general initializer for input raw state array.</p><pre><code class="language-none">register(::Val{InitMethod}, ::Type{RT}, ::Type{T}, n, nbatch)</code></pre><p>init register type <code>RT</code> with <code>InitMethod</code> type (e.g <code>Val{:zero}</code>) with element type <code>T</code> and total number qubits <code>n</code> with <code>nbatch</code>. This will be auto-binded to some shortcuts like <code>zero_state</code>, <code>rand_state</code>, <code>randn_state</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L3-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.DefaultRegister" href="#Yao.Registers.DefaultRegister"><code>Yao.Registers.DefaultRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DefaultRegister{B, T} &lt;: AbstractRegister{B, T}</code></pre><p>Default type for a quantum register. It contains a dense array that represents a batched quantum state with batch size <code>B</code> of type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.Focus" href="#Yao.Registers.Focus"><code>Yao.Registers.Focus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Focus{N} &lt;: AbatractBlock</code></pre><p>Focus manager, with N the number of qubits.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Focus.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.@bit_str-Tuple{Any}" href="#Yao.Registers.@bit_str-Tuple{Any}"><code>Yao.Registers.@bit_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@bit_str -&gt; QuBitStr</code></pre><p>Construct a bit string. such as <code>bit&quot;0000&quot;</code>. The bit strings also supports string concat. Just use it like normal strings.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/BitStr.jl#L19-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Intrinsics.hypercubic" href="#Yao.Intrinsics.hypercubic"><code>Yao.Intrinsics.hypercubic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hypercubic(r::AbstractRegister) -&gt; AbstractArray</code></pre><p>Return the hypercubic form (high dimensional tensor) of this register, only active qubits are considered.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.extend!-Union{Tuple{B}, Tuple{T}, Tuple{Yao.Registers.DefaultRegister{B,T},Int64}} where T where B" href="#Yao.Registers.extend!-Union{Tuple{B}, Tuple{T}, Tuple{Yao.Registers.DefaultRegister{B,T},Int64}} where T where B"><code>Yao.Registers.extend!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">extend!(r::DefaultRegister, n::Int) -&gt; DefaultRegister
extend!(n::Int) -&gt; Function</code></pre><p>extend the register by n bits in state |0&gt;. i.e. |psi&gt; -&gt; |000&gt; ⊗ |psi&gt;, extended bits have higher indices. If only an integer is provided, then perform lazy evaluation.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L82-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.focus!" href="#Yao.Registers.focus!"><code>Yao.Registers.focus!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">focus!(reg::DefaultRegister, bits::Ints) -&gt; DefaultRegister
focus!(locs::Int...) -&gt; Function</code></pre><p>Focus register on specified active bits.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L146-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.focuspair!-Tuple{Vararg{Int64,N} where N}" href="#Yao.Registers.focuspair!-Tuple{Vararg{Int64,N} where N}"><code>Yao.Registers.focuspair!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">focuspair(locs::Int...) -&gt; NTuple{2, Function}</code></pre><p>Return focus! and relax! function for specific lines.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Focus.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.isnormalized-Tuple{Yao.Registers.DefaultRegister}" href="#Yao.Registers.isnormalized-Tuple{Yao.Registers.DefaultRegister}"><code>Yao.Registers.isnormalized</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isnormalized(reg::DefaultRegister) -&gt; Bool</code></pre><p>Return true if a register is normalized else false.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L100-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure" href="#Yao.Registers.measure"><code>Yao.Registers.measure</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">measure(register, [n=1]) -&gt; Vector</code></pre><p>measure active qubits for <code>n</code> times.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Measure.jl#L14-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure_remove!-Union{Tuple{B}, Tuple{Yao.Registers.AbstractRegister{B,T} where T}} where B" href="#Yao.Registers.measure_remove!-Union{Tuple{B}, Tuple{Yao.Registers.AbstractRegister{B,T} where T}} where B"><code>Yao.Registers.measure_remove!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">measure_remove!(register)</code></pre><p>measure the active qubits of this register and remove them.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Measure.jl#L21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.register" href="#Yao.Registers.register"><code>Yao.Registers.register</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">register([type], bit_str, [nbatch=1]) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> by inputing a bit string, e.g</p><pre><code class="language-">using Yao
register(bit&quot;0000&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/BitStr.jl#L54-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.register-Tuple{Array{T,1} where T}" href="#Yao.Registers.register-Tuple{Array{T,1} where T}"><code>Yao.Registers.register</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">register(raw) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> from a raw dense array (<code>Vector</code> or <code>Matrix</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L28-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.relax!" href="#Yao.Registers.relax!"><code>Yao.Registers.relax!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">relax!(reg::DefaultRegister; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(reg::DefaultRegister, bits::Ints; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(bits::Ints...; nbit::Int=-1) -&gt; Function</code></pre><p>Inverse transformation of focus, with nbit is the number of active bits of target register.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L137-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.stack-Tuple{Vararg{Yao.Registers.DefaultRegister,N} where N}" href="#Yao.Registers.stack-Tuple{Vararg{Yao.Registers.DefaultRegister,N} where N}"><code>Yao.Registers.stack</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">stack(regs::DefaultRegister...) -&gt; DefaultRegister</code></pre><p>stack multiple registers into a batch.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.statevec" href="#Yao.Registers.statevec"><code>Yao.Registers.statevec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">statevec(r::AbstractRegister) -&gt; AbstractArray</code></pre><p>Return the raveled state (vector) form of this register.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L123-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.QuBitStr" href="#Yao.Registers.QuBitStr"><code>Yao.Registers.QuBitStr</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QuBitStr</code></pre><p>String literal for qubits.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/BitStr.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize!-Tuple{Yao.Registers.AbstractRegister}" href="#Base.LinAlg.normalize!-Tuple{Yao.Registers.AbstractRegister}"><code>Base.LinAlg.normalize!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">normalize!(r::AbstractRegister) -&gt; AbstractRegister</code></pre><p>Return the register with normalized state.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L116-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kron-Union{Tuple{B}, Tuple{RT,Yao.Registers.AbstractRegister{B,T} where T}, Tuple{RT}} where RT&lt;:(Yao.Registers.AbstractRegister{B,T} where T) where B" href="#Base.kron-Union{Tuple{B}, Tuple{RT,Yao.Registers.AbstractRegister{B,T} where T}, Tuple{RT}} where RT&lt;:(Yao.Registers.AbstractRegister{B,T} where T) where B"><code>Base.kron</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">kron(lhs, rhs)</code></pre><p>Merge two registers together with kronecker tensor product.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Core.jl#L105-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.shapeorder-Tuple{Tuple{Vararg{T,N}} where T where N,Array{Int64,1}}" href="#Yao.Registers.shapeorder-Tuple{Tuple{Vararg{T,N}} where T where N,Array{Int64,1}}"><code>Yao.Registers.shapeorder</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Get the compact shape and order for permutedims.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/ae20f962fe85ead2d79773ada5181c4f62c3cc6b/src/Registers/Default.jl#L107-L109">source</a></section><footer><hr/><a class="previous" href="../interfaces/"><span class="direction">Previous</span><span class="title">Interfaces</span></a><a class="next" href="../blocks/"><span class="direction">Next</span><span class="title">Blocks System</span></a></footer></article></body></html>
