<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Blocks · Yao.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/dev/extending-blocks/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transform</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/yao/">Yao</a></li><li><a class="toctext" href="../../man/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../man/registers/">Registers</a></li><li><a class="toctext" href="../../man/blocks/">Blocks System</a></li><li><a class="toctext" href="../../man/cache/">Cache System</a></li><li><a class="toctext" href="../../man/intrinsics/">Intrinsics</a></li><li><a class="toctext" href="../../man/luxurysparse/">LuxurySparse</a></li><li><a class="toctext" href="../../man/boost/">Boost</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li class="current"><a class="toctext" href>Extending Blocks</a><ul class="internal"><li><a class="toctext" href="#Extending-constant-gate-1">Extending constant gate</a></li><li><a class="toctext" href="#Extending-Primitive-Block-with-parameters-1">Extending Primitive Block with parameters</a></li><li><a class="toctext" href="#Extending-Composite-Blocks-1">Extending Composite Blocks</a></li><li><a class="toctext" href="#Custom-Pretty-Printing-1">Custom Pretty Printing</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li><a href>Extending Blocks</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/dev/extending-blocks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending Blocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Extending-Blocks-1" href="#Extending-Blocks-1">Extending Blocks</a></h1><h2><a class="nav-anchor" id="Extending-constant-gate-1" href="#Extending-constant-gate-1">Extending constant gate</a></h2><p>We prepared a macro for you about constant gates like <a href="../../man/interfaces/#Yao.Blocks.X"><code>X</code></a>, <a href="../../man/interfaces/#Yao.Blocks.Y"><code>Y</code></a>, <a href="../../man/interfaces/#Yao.Blocks.Z"><code>Z</code></a>.</p><p>Simply use <a href="../../man/blocks/#Yao.Blocks.ConstGateTools.@const_gate-Tuple{Any}"><code>@const_gate</code></a>.</p><h2><a class="nav-anchor" id="Extending-Primitive-Block-with-parameters-1" href="#Extending-Primitive-Block-with-parameters-1">Extending Primitive Block with parameters</a></h2><p><strong>First</strong>, define your own block type by subtyping <a href="../../man/blocks/#Yao.Blocks.PrimitiveBlock"><code>PrimitiveBlock</code></a>. And import methods you will need to overload</p><div><pre><code class="language-julia">using Yao, Yao.Blocks
import Yao.Blocks: mat, dispatch!, parameters # this is the mimimal methods you will need to overload

mutable struct NewPrimitive{T} &lt;: PrimitiveBlock{1, T}
   theta::T
end</code></pre></div><p><strong>Second</strong> define its matrix form.</p><div><pre><code class="language-julia">mat(g::NewPrimitive{T}) where T = Complex{T}[sin(g.theta) 0; cos(g.theta) 0]</code></pre><pre><code class="language-none">mat (generic function with 63 methods)</code></pre></div><p><strong>Yao</strong> will use this matrix to do the simulation by default. However, if you know how to directly apply your block to a quantum register, you can also overload <a href="../../man/blocks/#Yao.Blocks.apply!"><code>apply!</code></a> to make your simulation become more efficient. But this is not required.</p><pre><code class="language-julia">import Yao.Blocks: apply!
apply!(r::AbstractRegister, x::NewPrimitive) = # some efficient way to simulate this block</code></pre><p><strong>Third</strong> If your block contains parameters, declare which member it is with <a href="../../man/blocks/#Yao.Blocks.dispatch!"><code>dispatch!</code></a> and how to get them by <a href="../../man/blocks/#Yao.Blocks.parameters"><code>parameters</code></a></p><div><pre><code class="language-julia">dispatch!(g::NewPrimitive, theta) = (g.theta = theta; g)
parameters(x::NewPrimitive) = x.theta</code></pre><pre><code class="language-none">parameters (generic function with 6 methods)</code></pre></div><p>The prototype of <code>dispatch!</code> is simple, just directly write the parameters as your function argument. e.g</p><pre><code class="language-julia">mutable struct MultiParam{N, T} &lt;: PrimitiveBlock{N, Complex{T}}
  theta::T
  phi::T
end</code></pre><p>just write:</p><pre><code class="language-julia">dispatch!(x::MultiParam, theta, phi) = (x.theta = theta; x.phi = phi; x)</code></pre><p>or maybe your block contains a vector of parameters:</p><pre><code class="language-julia">mutable struct VecParam{N, T} &lt;: PrimitiveBlock{N, T}
  params::Vector{T}
end</code></pre><p>just write:</p><pre><code class="language-julia">dispatch!(x::VecParam, params) = (x.params .= params; x)</code></pre><p>be careful, the assignment should be in-placed with <code>.=</code> rather than <code>=</code>.</p><p>If the number of parameters in your new block is fixed, we recommend you to declare this with a type trait <a href="../../man/blocks/#Yao.Blocks.nparameters"><code>nparameters</code></a>:</p><div><pre><code class="language-julia">import Yao.Blocks: nparameters
nparameters(::Type{&lt;:NewPrimitive}) = 1</code></pre><pre><code class="language-none">nparameters (generic function with 7 methods)</code></pre></div><p>But it is OK if you do not define this trait, <strong>Yao</strong> will find out how many parameters you have dynamically.</p><p><strong>Fourth</strong> If you want to enable cache of this new block, you have to define your own cache_key. usually just use your parameters as the key if you want to cache the matrix form of different parameters, which will accelerate your simulation with a cost of larger memory allocation. You can simply define it with <a href="../../man/blocks/#Yao.Blocks.cache_key"><code>cache_key</code></a></p><div><pre><code class="language-julia">import Yao.Blocks: cache_key
cache_key(x::NewPrimitive) = x.theta</code></pre><pre><code class="language-none">cache_key (generic function with 11 methods)</code></pre></div><h2><a class="nav-anchor" id="Extending-Composite-Blocks-1" href="#Extending-Composite-Blocks-1">Extending Composite Blocks</a></h2><p>Composite blocks are blocks that are able to contain other blocks. To define a new composite block you only need to define your new type as a subtype of <a href="../../man/blocks/#Yao.Blocks.CompositeBlock"><code>CompositeBlock</code></a>, and define a new method called <a href="../../man/blocks/#Yao.Blocks.blocks"><code>blocks</code></a> which will provide an iterator that iterates the blocks contained by this composite block.</p><h2><a class="nav-anchor" id="Custom-Pretty-Printing-1" href="#Custom-Pretty-Printing-1">Custom Pretty Printing</a></h2><p>The whole quantum circuit is represented as a tree in the block system. Therefore, we print a block as a tree. To define your own syntax to print, simply overloads the <a href="../../man/blocks/#Yao.Blocks.print_block-Tuple{IO,Any}"><code>print_block</code></a> method. Then it will appears in the block tree syntax automatically.</p><pre><code class="language-julia">print_block(io::IO, block::MyBlockType)</code></pre><footer><hr/><a class="previous" href="../../man/boost/"><span class="direction">Previous</span><span class="title">Boost</span></a></footer></article></body></html>
