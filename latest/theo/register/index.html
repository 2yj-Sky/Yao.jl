<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Register · Quantum Circuit Simulation for Julia</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/QuCircuit.jl/latest/theo/register/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Quantum Circuit Simulation for Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transform</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/blocks/">Blocks as the basic component of a circuit</a></li><li><a class="toctext" href="../../man/cache/">Cache System</a></li><li><a class="toctext" href="../../man/functional/">Functional Programming</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../dev/block/">Block System</a></li><li><a class="toctext" href="../../dev/register/">Quantum Register</a></li><li><a class="toctext" href="../../dev/cache/">Cache</a></li><li><a class="toctext" href="../../dev/visualization/">Visualization</a></li><li><a class="toctext" href="../../dev/unittest/">Unit Test</a></li><li><a class="toctext" href="../../dev/APIs/">APIs</a></li></ul></li><li><span class="toctext">Theoretical Notes</span><ul><li class="current"><a class="toctext" href>Register</a><ul class="internal"><li><a class="toctext" href="#Storage-1">Storage</a></li><li><a class="toctext" href="#Operations-1">Operations</a></li></ul></li><li><a class="toctext" href="../rotation/">Rotation Block</a></li><li><a class="toctext" href="../grover/">Grover Search</a></li><li><a class="toctext" href="../blocks/">Block Operations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Theoretical Notes</li><li><a href>Register</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/QuCircuit.jl/blob/master/docs/src/theo/register.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Register</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Register-1" href="#Register-1">Register</a></h1><h2><a class="nav-anchor" id="Storage-1" href="#Storage-1">Storage</a></h2><h4><a class="nav-anchor" id="LDT-format-1" href="#LDT-format-1">LDT format</a></h4><p>Concepturely, a wave function <span>$|\psi\rangle$</span> can be represented in a low dimentional tensor (LDT) format of order-3, L(f, r, b).</p><ul><li><p>f: focused (i.e. operational) dimensions</p></li><li><p>r: remaining dimensions</p></li><li><p>b: batch dimension.</p></li></ul><p>For simplicity, let&#39;s ignore batch dimension for the momentum, we have</p><div>\[|\psi\rangle = \sum\limits_{x,y} L(x, y, .) |j\rangle|i\rangle\]</div><p>Given a configuration <code>x</code> (in operational space), we want get the i-th bit using <code>(x&lt;&lt;i) &amp; 0x1</code>, which means putting the small end the qubit with smaller index. In this representation <code>L(x)</code> will get return <span>$\langle x|\psi\rangle$</span>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Why not the other convension</strong>: Using the convention of putting 1st bit on the big end will need to know the total number of qubits <code>n</code> in order to know such positional information.</p></div></div><h4><a class="nav-anchor" id="HDT-format-1" href="#HDT-format-1">HDT format</a></h4><p>Julia storage is column major, if we reshape the wave function to a shape of <span>$2\times2\times ... \times2$</span> and get the HDT (high dimensional tensor) format representation H, we can use H(<span>$x_1, x_2, ..., x_3$</span>) to get <span>$\langle x|\psi\rangle$</span>.</p><h2><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h2><h4><a class="nav-anchor" id="Kronecker-product-of-operators-1" href="#Kronecker-product-of-operators-1">Kronecker product of operators</a></h4><p>In order to put small bits on little end, the Kronecker product is <span>$O = o_n \otimes \ldots \otimes o_2 \otimes o_1$</span> where the subscripts are qubit indices.</p><h4><a class="nav-anchor" id="Measurements-1" href="#Measurements-1">Measurements</a></h4><p>Measure means <code>sample</code> and <code>projection</code>.</p><h5><a class="nav-anchor" id="Sample-1" href="#Sample-1">Sample</a></h5><p>Suppose we want to measure operational subspace, we can first get</p><div>\[p(x) = \|\langle x|\psi\rangle\|^2 = \sum\limits_{y} \|L(x, y, .)\|^2.\]</div><p>Then we sample an <span>$a\sim p(x)$</span>. If we just sample and don&#39;t really measure (change wave function), its over.</p><h5><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h5><div>\[|\psi\rangle&#39; = \sum_y L(a, y, .)/\sqrt{p(a)} |a\rangle |y\rangle\]</div><p>Good! then we can just remove the operational qubit space since <code>x</code> and <code>y</code> spaces are totally decoupled and <code>x</code> is known as in state <code>a</code>, then we get</p><div>\[|\psi\rangle&#39;_r = \sum_y l(0, y, .) |y\rangle\]</div><p>where <code>l = L(a:a, :, :)/sqrt(p(a))</code>.</p><footer><hr/><a class="previous" href="../../dev/APIs/"><span class="direction">Previous</span><span class="title">APIs</span></a><a class="next" href="../rotation/"><span class="direction">Next</span><span class="title">Rotation Block</span></a></footer></article></body></html>
