---
options:
    out_path: QFT.md
    fig_path: ../assets/figures
    doctype: github
---


# Quantum Fourier Transformation and Phase Estimation

Let's use Yao first

```julia
using Yao
```

## Quantum Fourier Transformation

The Quantum Fourier Transformation (QFT) circuit is to repeat
two kinds of blocks repeatly:

![ghz](../assets/figures/qft.png)

The basic building block control phase shift gate is defined
as

```math
R(k)=\begin{bmatrix}
1 & 0\\
0 & \exp\left(\frac{2\pi i}{2^k}\right)
\end{bmatrix}
```

Let's define block `A` and block `B`, block `A` is actually
a control block.

```julia
A(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))))
```

Once you construct the blockl you can inspect its matrix using [`mat`](@ref)
function. Let's construct the circuit in dash box A, and see the matrix of
``R_4`` gate.

```julia
R4 = A(1, 4)
```

If you have read about [preparing GHZ state](@ref example-ghz),
you probably know that in Yao, we could just leave the number of qubits, and it
will be evaluated when possible.

```julia
R4(5)
```

its matrix will be

```
mat(R4(5))
```

Then we repeat this control block over
and over on different qubits, and put a Hadmard gate
to `i`th qubit to construct `i`-th `B` block.

```julia
B(n, i) = chain(n, i==j ? put(i=>H) : A(j, i) for j in i:n)
```

We need to input the total number of qubits `n` here because we have to iterate
through from `i`-th location to the last.

Now, let's construct the circuit by chaining all the `B` blocks together

```julia
qft(n) = chain(B(n, i) for i in 1:n)

qft(4)
```

## Wrap QFT to an external block

In most cases, `function`s are enough to wrap quantum circuits, like `A`
and `B` we defined above, but sometimes, we need to dispatch specialized
methods on certain kinds of quantum circuit, or we want to define an external
block to export, thus, it's useful to be able to wrap circuit to custom blocks.

First, we define a new type as subtype of [`PrimitiveBlock`](@ref) since we are not
going to use the subblocks of `QFT`, if you need to use its subblocks, it'd
be better to define it under [`CompositeBlock`](@ref).

```julia
struct QFT{N, T} <: PrimitiveBlock{N, T} end

QFT(::Type{T}, n::Int) where T = QFT{n, T}()
QFT(n::Int) = QFT(ComplexF64, n)
```

Now, let's define its circuit

```julia
circuit(::QFT{N}) where N = qft(N)
```

And forward [`mat`](@ref) to its circuit's matrix

```julia
YaoBlocks.mat(x::QFT) = mat(circuit(x))
```

You may notice, it is a little ugly to print `QFT` at the moment,
this is because we print the type summary by default, you can define
your own printing by overloading [`print_block`](@ref)

```julia
YaoBlocks.print_block(io::IO, x::QFT{N}) where N = print(io, "QFT($N)")
```

Since it is possible to use FFT to simulate the results of QFT (like cheating),
we could define our custom [`apply!`](@ref) method:

```julia
using FFTW, LinearAlgebra

function YaoBlocks.apply!(r::ArrayReg, x::QFT)
    α = sqrt(length(statevec(r)))
    invorder!(r)
    lmul!(α, ifft!(statevec(r)))
    return r
end
```

Now let's check if our `apply!` method is correct:

```julia
r = rand_state(5)
r1 = r |> copy |> QFT(5)
r2 = r |> copy |> circuit(QFT(5))
r1 ≈ r2
```

We can get IQFT (inverse QFT) directly by calling `adjoint`

```julia
QFT(5)'
```

QFT and IQFT are different from FFT and IFFT in three ways,

1. they are different by a factor of ``\sqrt{2^n}`` with ``n`` the number of qubits.
2. the [bit numbering](https://quantumbfs.github.io/BitBasis.jl/stable/tutorial/#Conventions-1) will exchange after applying QFT or IQFT.
3. due to the convention, QFT is more related to IFFT rather than FFT.

## Phase Estimation

Since we have QFT and IQFT blocks we can then use them to
realize phase estimation circuit, what we want to realize
is the following circuit:

![phase estimation](../assets/figures/phaseest.png)

```julia
using Yao
```

First we call hadmard gates repeatly on first `n` qubits.

```julia
A(n) = repeat(H, 1:n)
```

Then in dashed box `B`, we have controlled unitaries:

```julia
B(n, m, U) = chain(n+m, control(k, n+1:n+m=>matblock(U^(2^(k-1)))) for k in 1:n)
```

each of them is a `U` of power ``2^(k-1)``.

Since we will only apply the qft and hadmard on first `n` qubits,
we could use [`Concentrator`](@ref), which creates a context of
a sub-scope of the qubits.

```julia
PE(n, m, U) =
    chain(n+m, concentrate(A(n), 1:n), B(n, m, U), concentrate(QFT(n)', 1:n))
```

we use the first `n` qubits as the output space to store phase ``ϕ``, and the
other `m` qubits as the input state which corresponds to an eigenvector of
oracle matrix `U`.

The concentrator here uses [`focus!`](@ref) and [`relax!`](@ref) to manage
a local scope of quantum circuit, and only active the first `n` qubits while applying
the block inside the concentrator context, and the scope will be [`relax!`](@ref)ed
back, after the context. This is equivalent to manually [`focus!`](@ref)
then [`relax!`](@ref)


fullly activated

```julia
r = rand_state(5)
```

first 3 qubits activated

```julia
focus!(r, 1:3)
```

relax back to the original

```julia
relax!(r, 1:3)
```

In this way, we will be able to apply small operator directly
on the subset of the qubits.

Details about the algorithm can be found here:
[Quantum Phase Estimation Algorithm](ttps://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm)
